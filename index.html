<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DVD Logo Idle</title> <!-- Updated Title -->
    <style>
        :root {
            --tv-bg: #333;
            --screen-bg: #1a1a1a; /* Slightly Lighter Screen BG */
            --text-color: #eee;
            --border-color: #555;
            --highlight-color: #ff0; /* Yellow for Corners */
            --highlight-color-hits: #0cf; /* Cyan for Hits */
            --meta-color: #f0f; /* Magenta for Meta Fragments */
            --disabled-color: #777;
            --spark-color-1: #fff;
            --spark-color-2: #ff0;
            --logo-brightness: 1.1; /* Make logo slightly brighter */
            --perfect-hit-color: #ffaa00; /* Orange for perfect/crit */
            --corner-hit-color: #0f0; /* Green for corner hit text */


            /* Dynamic logo size variables - set by JS */
            --logo-dynamic-height: 30px; /* Default fallback (larger) */
            --logo-dynamic-width: 48px; /* Default fallback (larger) */
        }

        html, body { margin: 0; padding: 0; width: 100%; background-color: #111; font-family: 'Courier New', Courier, monospace; color: var(--text-color); display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; }
            #game-container { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 800px; padding: 2vh 10px; box-sizing: border-box; }
            #tv-frame { background-color: var(--tv-bg); border: 10px solid var(--border-color); border-radius: 25px / 40px; padding: 15px; box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.6); margin-bottom: 15px; position: relative; width: 90vw; max-width: 600px; aspect-ratio: 16 / 9; display: flex; justify-content: center; align-items: center; flex-shrink: 0; /* Remove transition: box-shadow 0.5s ease-in-out; /* For Overcharge effect */ }

            #tv-screen {
                width: 100%; height: 100%;
                background-color: var(--screen-bg);
                position: relative;
                overflow: hidden;
                border-radius: 5px;
                box-shadow: inset 0 0 15px rgba(0,0,0,0.7);
                filter: url(#crt-effect);
            }

            #tv-screen::before { /* Scanlines */
                content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
                background-size: 100% 3px, 6px 100%;
                z-index: 2; pointer-events: none; animation: crt-scanline 120s linear infinite;
            }
            #tv-screen::after { /* No Vignette */
                content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                border-radius: inherit; z-index: 3; pointer-events: none;
            }
            @keyframes crt-scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

            /* --- DVD Logo Box Style --- */
            .box {
                position: absolute;
                background-color: #ffffff; /* Start white, changes dynamically */
                /* Use dynamic size variables */
                width: var(--logo-dynamic-width);
                height: var(--logo-dynamic-height);
                mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
                -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
                mask-size: contain; -webkit-mask-size: contain;
                mask-repeat: no-repeat; -webkit-mask-repeat: no-repeat;
                mask-position: center; -webkit-mask-position: center;
                transition: background-color 0.1s ease-out;
                z-index: 1;
                filter: brightness(var(--logo-brightness)); /* Make logo slightly brighter */
            }

            /* --- Flash & Particle Effects --- */
            .corner-hit-flash {
                background-color: var(--highlight-color) !important; /* Yellow flash for corners */
                z-index: 5;
            }
            .perfect-hit-flash { /* New flash for perfect/critical hits */
                 background-color: var(--perfect-hit-color) !important; /* Orange flash */
                 filter: brightness(1.5) !important; /* Make it extra bright */
                 z-index: 6; /* Above normal corner flash */
            }
            .spark-particle {
                position: absolute; width: 3px; height: 3px; border-radius: 50%;
                pointer-events: none; z-index: 10; opacity: 1;
                transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.9, 1), opacity 0.6s ease-out;
            }

            /* --- Screen Overcharge Effect (CSS remains, JS logic removed) --- */
            #tv-frame.overcharged {
                box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.6), 0 0 15px 5px var(--highlight-color-hits);
                animation: pulseGlow 2s infinite alternate ease-in-out;
            }
            @keyframes pulseGlow {
                from { box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.6), 0 0 10px 3px var(--highlight-color-hits); }
                to { box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.6), 0 0 25px 8px var(--highlight-color); }
            }


            /* --- Controls & Score --- */
            #controls { text-align: center; width: 95%; max-width: 700px; display: flex; flex-direction: column; gap: 15px; padding-bottom: 20px; }
            .section-header { font-size: clamp(1.1rem, 3.2vw, 1.5rem); margin-bottom: 10px; font-weight: bold; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; margin-top: 20px; }
            .score-area { display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 5px; }
            .score-display { font-size: clamp(1.1rem, 3vw, 1.6rem); font-weight: bold; padding: 5px 10px; border-radius: 5px; background-color: #222; flex-grow: 1; text-align: center;}
            #corner-score-display { color: var(--highlight-color); text-shadow: 0 0 5px var(--highlight-color); border: 1px solid var(--highlight-color); }
            #hit-score-display { color: var(--highlight-color-hits); text-shadow: 0 0 5px var(--highlight-color-hits); border: 1px solid var(--highlight-color-hits); }
            #meta-score-display { color: var(--meta-color); text-shadow: 0 0 5px var(--meta-color); border: 1px solid var(--meta-color); margin-top: 5px; font-size: clamp(1rem, 2.8vw, 1.4rem); } /* For Fragments */
            #streak-display { font-size: clamp(0.9rem, 2.5vw, 1.1rem); color: var(--text-color); text-shadow: 0 0 3px var(--text-color); margin-top: -10px; margin-bottom: 5px; height: 1.2em; opacity: 0; transition: opacity 0.3s ease-in-out; }
            #streak-display.visible { opacity: 1; }

            /* --- Upgrades --- */
            .upgrades-container { border: 2px solid var(--border-color); border-radius: 8px; padding: 10px; background-color: rgba(0,0,0,0.2); }
            .upgrades-header { font-size: clamp(1rem, 3vw, 1.3rem); margin-bottom: 10px; font-weight: bold; }
            #corner-upgrades-header { color: var(--highlight-color); }
            #hit-upgrades-header { color: var(--highlight-color-hits); }
            #meta-upgrades-header { color: var(--meta-color); } /* For Meta */
            /* --- Adjusted minmax for better column wrapping --- */
            .upgrades-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(125px, 1fr)); gap: 8px; width: 100%; }
            .upgrade-button { background-color: var(--border-color); color: var(--text-color); border: 2px solid var(--tv-bg); padding: 8px 5px; border-radius: 5px; cursor: pointer; font-size: clamp(0.75rem, 2.2vw, 0.95rem); transition: background-color 0.2s, transform 0.1s; text-align: center; min-height: 65px; /* Increased height */ display: flex; flex-direction: column; justify-content: center; align-items: center; }
            .upgrade-button:hover:not(:disabled) { background-color: #666; }
            .upgrade-button:active:not(:disabled) { transform: scale(0.95); }
            .upgrade-button:disabled { background-color: #444; color: var(--disabled-color); cursor: not-allowed; opacity: 0.7; }
            .upgrade-cost { font-size: 0.85em; font-weight: bold; margin-top: 4px; }
            .upgrade-cost.corner { color: var(--highlight-color); }
            .upgrade-cost.hit { color: var(--highlight-color-hits); }
            .upgrade-cost.meta { color: var(--meta-color); } /* For Meta */

            /* --- Reboot Section --- */
            #reboot-section { margin-top: 20px; padding: 15px; border: 2px dashed var(--meta-color); border-radius: 8px; background-color: rgba(50, 0, 50, 0.2); text-align: center; }
            #reboot-info { margin-bottom: 10px; font-size: 0.9em; }
            #reboot-gain-preview { margin-bottom: 10px; font-weight: bold; } /* Added margin */
            #reboot-button { background-color: var(--meta-color); color: #fff; border: 2px solid #303; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1.1rem; font-weight: bold; transition: background-color 0.2s, transform 0.1s; }
            #reboot-button:hover { background-color: #ff40ff; }
            #reboot-button:active { transform: scale(0.95); }
            #reboot-button:disabled { background-color: #606; color: var(--disabled-color); cursor: not-allowed; }

            /* --- Notification --- */
            #notification { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 130, 150, 0.85); /* Changed from green to dark cyan/teal */ color: white; padding: 8px 15px; border-radius: 5px; font-size: 0.9rem; opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none; z-index: 1000; }
            #notification.show { opacity: 1; }
            #notification.perfect { background-color: rgba(255, 150, 0, 0.9); font-weight: bold; } /* Style for special notifications */

            /* --- Critical Hit Text --- */
            .critical-hit-text {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-family: 'Courier New', Courier, monospace;
                font-size: clamp(2rem, 6vw, 3rem); /* Responsive size */
                font-weight: bold;
                text-shadow: 2px 2px #333, 0 0 10px #fff; /* Basic CRT glow */
                z-index: 100;
                pointer-events: none;
                opacity: 0; /* Start hidden */
                animation: criticalHitAnim 1.2s ease-out forwards;
            }

            @keyframes criticalHitAnim {
                0% { opacity: 1; transform: translate(-50%, -50%); } /* Appear center */
                50% { opacity: 1; }
                100% { opacity: 0; transform: translate(-50%, -120%); } /* Move up and fade out */
            }

            /* --- Corner Hit Text (NEW) --- */
            .corner-hit-text {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--corner-hit-color); /* Use CSS variable */
                font-family: 'Courier New', Courier, monospace;
                font-size: clamp(1.8rem, 5.5vw, 2.8rem); /* Slightly smaller than critical */
                font-weight: bold;
                text-shadow: 1px 1px black, 0 0 15px var(--corner-hit-color), 0 0 5px white; /* More intense glow */
                z-index: 99; /* Below critical if they overlap */
                pointer-events: none;
                opacity: 0; /* Start hidden */
                animation: cornerHitAnim 1.0s ease-out forwards; /* Slightly faster animation */
            }

            @keyframes cornerHitAnim {
                0% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); } /* Appear center, slightly larger */
                50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -130%) scale(0.8); } /* Move up faster, shrink slightly */
            }


    </style>

</head>
<body>

<!-- SVG Filter Definition -->
<svg style="position:absolute; height: 0; width: 0;" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <filter id="crt-effect">
      <feGaussianBlur stdDeviation="0.4" result="blurred"/>
      <feComponentTransfer in="blurred" result="contrastBoost">
         <feFuncR type="linear" slope="1.1" intercept="-0.02"/>
         <feFuncG type="linear" slope="1.1" intercept="-0.02"/>
         <feFuncB type="linear" slope="1.1" intercept="-0.02"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<!-- HTML Elements -->
<div id="game-container">
    <div id="tv-frame">
        <div id="tv-screen">
            <!-- Boxes (Logos) & Particles added here by JS -->
            <!-- Critical/Corner Hit Text will be added here by JS -->
        </div>
    </div>

    <div id="controls">
        <div class="score-area">
            <!-- Corner score display will be hidden/shown by JS -->
            <div id="corner-score-display" class="score-display" style="display: none;">Corners: 0</div>
            <div id="hit-score-display" class="score-display">Hits: 0</div>
        </div>
         <!-- Added ID to this row for visibility control -->
         <div id="meta-score-row" class="score-area" style="display: none;"> <!-- Second row for Meta Score -->
            <div id="meta-score-display" class="score-display">Fragments: 0</div>
         </div>

        <div id="streak-display">Streak: 0 (x1.00)</div>


        <!-- HIT UPGRADES FIRST -->
         <div class="upgrades-container">
             <div id="hit-upgrades-header" class="upgrades-header">Hit Upgrades</div>
            <div id="hit-upgrades-section" class="upgrades-section"></div>
        </div>
        <!-- CORNER UPGRADES SECOND (Added Outer Container ID) -->
        <!-- This container will be hidden/shown by JS -->
        <div id="corner-upgrades-outer-container" class="upgrades-container" style="display: none;">
            <div id="corner-upgrades-header" class="upgrades-header">Corner Upgrades</div>
            <div id="corner-upgrades-section" class="upgrades-section"></div>
        </div>

         <!-- Reboot Section -->
         <div id="reboot-section" style="display: none;"> <!-- Initially hidden -->
             <div class="section-header" style="color: var(--meta-color);">System Reboot</div>
             <div id="reboot-info">Reboot to gain System Fragments based on total corners this run.<br>Fragments grant permanent Meta Upgrades.</div>
             <div id="reboot-gain-preview">You will gain ~0 Fragments on Reboot.</div>
             <button id="reboot-button">Reboot System</button>
         </div>

         <!-- Meta Upgrades -->
         <div id="meta-upgrades-container" class="upgrades-container" style="display: none;"> <!-- Initially hidden -->
              <div id="meta-upgrades-header" class="upgrades-header">Fragment Upgrades</div>
             <div id="meta-upgrades-section" class="upgrades-section"></div>
         </div>

    </div>
</div>

<div id="notification"></div>
<!-- End of HTML Elements -->

<!-- JavaScript -->
<script>
    (function() { // IIFE

        // --- Game Constants ---
        // --- Logo Size Control ---
        const LOGO_HEIGHT_SCREEN_RATIO = 0.2; // <<< ADJUST THIS VALUE (e.g., 0.10 = 10% of screen height)
        const BOX_ASPECT_RATIO = 1.6; // DVD logo aspect ratio

        // --- Other Constants ---
        let screenWidth = 0, screenHeight = 0;
        const HIT_STREAK_WINDOW_MS = 800;
        const SAVE_VERSION = 'v2'; // Increment save version for new upgrades
        const SAVE_KEY = `idleBoxBounceSave_${SAVE_VERSION}`;
        const REBOOT_CORNER_THRESHOLD = 10; // Min total corners before reboot is suggested/worth it

        // --- DOM Element Selection ---
        const tvFrameElement = document.getElementById('tv-frame');
        const tvScreenElement = document.getElementById('tv-screen');
        const cornerScoreElement = document.getElementById('corner-score-display');
        const hitScoreElement = document.getElementById('hit-score-display');
        const metaScoreElement = document.getElementById('meta-score-display');
        const streakDisplayElement = document.getElementById('streak-display');
        const cornerUpgradesContainer = document.getElementById('corner-upgrades-section');
        const hitUpgradesContainer = document.getElementById('hit-upgrades-section');
        const metaUpgradesContainer = document.getElementById('meta-upgrades-section');
        const notificationElement = document.getElementById('notification');
        const rebootSectionElement = document.getElementById('reboot-section');
        const rebootButtonElement = document.getElementById('reboot-button');
        const rebootGainPreviewElement = document.getElementById('reboot-gain-preview');
        const metaUpgradesOuterContainer = document.getElementById('meta-upgrades-container');
        // Elements for visibility control
        const metaScoreRowElement = document.getElementById('meta-score-row');
        const cornerUpgradesOuterContainerElement = document.getElementById('corner-upgrades-outer-container');


        // --- Game State ---
        let gameState; // Initialized in init()
        let nextBoxId = 0;
        function getNextBoxId() { return nextBoxId++; }

        // --- Dynamic Sizing Variables ---
        let dynamicBoxWidth = 40; // Default values
        let dynamicBoxHeight = 25;

        // --- Utility/Calculation Functions ---
        const calculateCost = (baseCost, level, factor = 1.5) => Math.max(1, Math.floor(baseCost * Math.pow(factor, level)));
        function getCurrentSpeed() { const speed = Math.max(1, gameState.baseSpeed * gameState.baseSpeedHits * gameState.metaSpeedBoost); return isNaN(speed) ? 1 : speed; }
        function calculateFragmentGain(totalCorners) {
            if (totalCorners < REBOOT_CORNER_THRESHOLD) return 0;
            const gain = Math.floor(Math.pow(Math.log10(totalCorners + 1), 1.8) * gameState.metaFragmentMultiplier);
            return Math.max(0, gain);
        }

        // --- Random Color Generator (Ensures better contrast) ---
        function getRandomColor() {
          let r, g, b;
          let color = '#';
          const letters = '0123456789ABCDEF';
          do {
              color = '#'; // Reset color string
              for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; }
              r = parseInt(color.substring(1, 3), 16);
              g = parseInt(color.substring(3, 5), 16);
              b = parseInt(color.substring(5, 7), 16);
          } while (r + g + b < 350); // Increased minimum brightness sum
          return color;
        }

        // --- Box Creation ---
        function createBoxElement(id) {
            if (!tvScreenElement) { console.error("tvScreenElement missing"); return null; }
            const boxElement = document.createElement('div');
            boxElement.classList.add('box'); boxElement.id = `box-${id}`;
            tvScreenElement.appendChild(boxElement);
            return boxElement;
        }
        function addBox(isInitial = false) {
            if (!screenWidth || !screenHeight || !tvScreenElement) { setTimeout(() => addBox(isInitial), 100); return; }
            const id = getNextBoxId();
            const initialSpeed = getCurrentSpeed() || 1;
            const startSpeedFactor = 0.6;

            // --- MODIFIED: Generate angle biased towards diagonals ---
            const baseAngleRange = Math.PI / 6; // 30 degrees range (e.g., 30-60)
            const baseAngleOffset = Math.PI / 6; // Start at 30 degrees
            const randomBaseAngle = Math.random() * baseAngleRange + baseAngleOffset; // Angle between 30 and 60 degrees
            const randomQuadrant = Math.floor(Math.random() * 4); // 0, 1, 2, or 3
            const finalAngle = randomBaseAngle + randomQuadrant * (Math.PI / 2); // Add quadrant offset (0, 90, 180, 270 deg)
            // --- END MODIFICATION ---

            const newBox = {
                id: id,
                x: isInitial ? screenWidth / 2 - dynamicBoxWidth / 2 : Math.random() * (screenWidth - dynamicBoxWidth),
                y: isInitial ? screenHeight / 2 - dynamicBoxHeight / 2 : Math.random() * (screenHeight - dynamicBoxHeight),
                vx: Math.cos(finalAngle) * initialSpeed * startSpeedFactor, // Use finalAngle
                vy: Math.sin(finalAngle) * initialSpeed * startSpeedFactor, // Use finalAngle
                element: createBoxElement(id)
            };
            if (isNaN(newBox.vx)) newBox.vx = initialSpeed * startSpeedFactor; // Fallback
            if (isNaN(newBox.vy)) newBox.vy = 0; // Fallback
            if (newBox.element) {
                newBox.element.style.left = `${newBox.x}px`;
                newBox.element.style.top = `${newBox.y}px`;
                gameState.boxes.push(newBox);
                console.log(`Added box ${id}, total: ${gameState.boxes.length}, Angle: ${(finalAngle * 180 / Math.PI).toFixed(1)}Â°`);
            } else { console.error("Failed element create in addBox."); }
        }
        function removeAllBoxes() {
            tvScreenElement?.querySelectorAll('.box').forEach(el => el.remove());
            if (gameState) { gameState.boxes = []; }
            nextBoxId = 0;
            console.log("Removed all box elements from screen.");
        }

         // --- Upgrade Definitions ---
         const cornerUpgrades = [
             { id: 'cornerMultiplier', name: 'Corner Value', baseCost: 1, costFactor: 1.9, maxLevel: 30, getLevel: () => gameState.cornerMultiplierLevel, applyEffect: () => { gameState.cornerMultiplierLevel++; recalculateDerivedState(); showNotification(`Corner Hits grant ${formatScore(gameState.cornerHitValue)}!`); }, getDescription: (l, c) => `Lv ${l}: Get ${formatScore(deriveCornerValue(l+1))} per corner.<br>Cost: <span class="upgrade-cost corner">${formatScore(c)}</span>` },
             { id: 'perfectCorner', name: 'Perfect Corner', baseCost: 25, costFactor: 2.2, maxLevel: 20, getLevel: () => gameState.perfectCornerLevel, applyEffect: () => { gameState.perfectCornerLevel++; recalculateDerivedState(); showNotification(`Perfect Corner chance/mult increased!`); }, getDescription: (l, c) => { const [chance, mult] = derivePerfectCornerStats(l+1); return `Lv ${l}: ${chance.toFixed(1)}% chance for x${mult.toFixed(1)} Corners.<br>Cost: <span class="upgrade-cost corner">${formatScore(c)}</span>`; } }, // Updated desc for float mult
             { id: 'precisionTuning', name: 'Precision Tuning', baseCost: 500, costFactor: 3.0, maxLevel: 15, getLevel: () => gameState.precisionTuningLevel, applyEffect: () => { gameState.precisionTuningLevel++; recalculateDerivedState(); showNotification(`Corner value & base Hit value increased!`); }, getDescription: (l, c) => `Lv ${l}: +Corners, +${(derivePrecisionHitBoost(l+1)*100).toFixed(0)}% base Hits.<br>Cost: <span class="upgrade-cost corner">${formatScore(c)}</span>` },
             { id: 'multiBox', name: 'Add Logo', baseCost: 50, costFactor: 4, maxLevel: 5, getLevel: () => gameState.multiBoxLevel, applyEffect: () => { gameState.multiBoxLevel++; addBox(); showNotification(`Added another logo! Total: ${gameState.boxes.length}`); }, getDescription: (l, c) => `Lv ${l}: Add logo (${gameState.boxes.length} total).<br>Cost: <span class="upgrade-cost corner">${formatScore(c)}</span>` },
             { id: 'syncBonus', name: 'Sync Bonus', baseCost: 100, costFactor: 2.5, maxLevel: 10, getLevel: () => gameState.syncBonusLevel, applyEffect: () => { gameState.syncBonusLevel++; recalculateDerivedState(); showNotification(`Simultaneous corner hits x${gameState.syncCornerMultiplier.toFixed(1)} bonus!`); }, getDescription: (l, c) => `Lv ${l}: Multi-logo corner hits x${deriveSyncBonus(l+1).toFixed(1)} bonus.<br>Cost: <span class="upgrade-cost corner">${formatScore(c)}</span>` },
             // <<< NEW CORNER UPGRADE (Replaced Screen Overcharge) >>>
             { id: 'cornerEcho', name: 'Corner Echo', baseCost: 200, costFactor: 2.0, maxLevel: 15, getLevel: () => gameState.cornerEchoLevel, applyEffect: () => { gameState.cornerEchoLevel++; recalculateDerivedState(); showNotification(`Corner Echo gains bonus corners based on Hits!`); }, getDescription: (l, c) => `Lv ${l}: Corner hits gain +${(deriveCornerEchoBonus(l+1)*100).toFixed(1)}% of Hits Score.<br>Cost: <span class="upgrade-cost corner">${formatScore(c)}</span>` },
         ];
         const hitUpgrades = [
             { id: 'hitValue', name: 'Hit Value', baseCost: 10, costFactor: 1.6, maxLevel: 30, getLevel: () => gameState.hitValueLevel, applyEffect: () => { gameState.hitValueLevel++; recalculateDerivedState(); showNotification(`Wall hits grant ${formatScore(gameState.hitValue)} Hits!`); }, getDescription: (l, c) => `Lv ${l}: Get ${formatScore(deriveHitValue(l+1))} H/bounce.<br>Cost: <span class="upgrade-cost hit">${formatScore(c)}</span>` },
             { id: 'criticalHit', name: 'Critical Hit', baseCost: 100, costFactor: 2.1, maxLevel: 20, getLevel: () => gameState.criticalHitLevel, applyEffect: () => { gameState.criticalHitLevel++; recalculateDerivedState(); showNotification(`Critical Hit chance/mult increased!`); }, getDescription: (l, c) => { const [chance, mult] = deriveCriticalHitStats(l+1); return `Lv ${l}: ${chance.toFixed(1)}% chance for x${mult.toFixed(1)} Hits.<br>Cost: <span class="upgrade-cost hit">${formatScore(c)}</span>`; } }, // Updated desc for float mult
             { id: 'momentumDrive', name: 'Momentum Drive', baseCost: 2500, costFactor: 2.8, maxLevel: 15, getLevel: () => gameState.momentumDriveLevel, applyEffect: () => { gameState.momentumDriveLevel++; recalculateDerivedState(); showNotification(`Hit value & base Corner value increased!`); }, getDescription: (l, c) => `Lv ${l}: +Hits, +${(deriveMomentumCornerBoost(l+1)*100).toFixed(0)}% base Corners.<br>Cost: <span class="upgrade-cost hit">${formatScore(c)}</span>` },
             { id: 'speedHits', name: 'Speed (Hits)', baseCost: 5, costFactor: 1.5, maxLevel: 30, getLevel: () => gameState.speedLevelHits, applyEffect: () => { gameState.speedLevelHits++; recalculateDerivedState(); showNotification("Speed Increased (via Hits)!"); }, getDescription: (l, c) => `Lv ${l}: Faster logos.<br>Cost: <span class="upgrade-cost hit">${formatScore(c)}</span>` },
             { id: 'hitStreak', name: 'Hit Streak', baseCost: 75, costFactor: 1.9, maxLevel: 20, getLevel: () => gameState.hitStreakLevel, applyEffect: () => { gameState.hitStreakLevel++; recalculateDerivedState(); showNotification(`Hit Streak bonus increased!`); }, getDescription: (l, c) => { const bonusPerHit = deriveStreakBonusPerHit(l+1); return `Lv ${l}: Rapid hits boost mult (+${(bonusPerHit*100).toFixed(1)}%/hit).<br>Cost: <span class="upgrade-cost hit">${formatScore(c)}</span>`; } },
             { id: 'ricochet', name: 'Ricochet Hits', baseCost: 150, costFactor: 1.7, maxLevel: 25, getLevel: () => gameState.ricochetLevel, applyEffect: () => { gameState.ricochetLevel++; recalculateDerivedState(); showNotification(`Ricochet chance/bonus increased!`); }, getDescription: (l, c) => { const [chance, bonus] = deriveRicochetStats(l+1); return `Lv ${l}: ${chance.toFixed(1)}% chance on wall hit for +${formatScore(bonus)} bonus Hits.<br>Cost: <span class="upgrade-cost hit">${formatScore(c)}</span>`; } },
         ];
         const metaUpgrades = [
             { id: 'metaStartCornerMult', name: 'Corner Start', baseCost: 1, costFactor: 2.5, maxLevel: 10, getLevel: () => gameState.metaStartCornerMultLevel, applyEffect: () => { gameState.metaStartCornerMultLevel++; recalculateDerivedState(); showNotification(`Starting Corner multiplier increased!`); }, getDescription: (l, c) => `Lv ${l}: Start with +${deriveMetaStartCornerMult(l+1)} base Corner mult.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaStartHitMult', name: 'Hit Start', baseCost: 2, costFactor: 2.5, maxLevel: 10, getLevel: () => gameState.metaStartHitMultLevel, applyEffect: () => { gameState.metaStartHitMultLevel++; recalculateDerivedState(); showNotification(`Starting Hit multiplier increased!`); }, getDescription: (l, c) => `Lv ${l}: Start with +${deriveMetaStartHitMult(l+1)} base Hit mult.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaFragmentGain', name: 'Fragment Bonus', baseCost: 5, costFactor: 3, maxLevel: 15, getLevel: () => gameState.metaFragmentGainLevel, applyEffect: () => { gameState.metaFragmentGainLevel++; recalculateDerivedState(); showNotification(`Gain more Fragments on Reboot!`); }, getDescription: (l, c) => `Lv ${l}: +${((deriveMetaFragmentMult(l+1)-1)*100).toFixed(0)}% Fragment gain.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaSpeed', name: 'Permanent Speed', baseCost: 10, costFactor: 4, maxLevel: 5, getLevel: () => gameState.metaSpeedLevel, applyEffect: () => { gameState.metaSpeedLevel++; recalculateDerivedState(); showNotification(`Permanent speed boost!`); }, getDescription: (l, c) => `Lv ${l}: +${((deriveMetaSpeedBoost(l+1)-1)*100).toFixed(0)}% base speed.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             // <<< NEW META UPGRADE 1 >>>
             { id: 'metaStreakStart', name: 'Streak Starter', baseCost: 8, costFactor: 3.5, maxLevel: 10, getLevel: () => gameState.metaStreakStartLevel, applyEffect: () => { gameState.metaStreakStartLevel++; recalculateDerivedState(); showNotification(`Permanent base Hit Streak bonus!`); }, getDescription: (l, c) => `Lv ${l}: +${(deriveMetaStreakStartBonus(l+1)).toFixed(2)} base streak mult.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             // <<< NEW META UPGRADE 2 >>>
             { id: 'metaCritPower', name: 'Enhanced Crits', baseCost: 15, costFactor: 4.0, maxLevel: 8, getLevel: () => gameState.metaCritPowerLevel, applyEffect: () => { gameState.metaCritPowerLevel++; recalculateDerivedState(); showNotification(`Permanent boost to Critical Hit multiplier!`); }, getDescription: (l, c) => `Lv ${l}: +${deriveMetaCritPowerBonus(l+1).toFixed(2)}x crit multiplier.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
         ];

        // --- Core Game Logic ---
        let lastTimestamp = 0;
        let lastSaveTime = 0;
        let gameLoopRunning = false;

        function update(timestamp) {
            if (!gameLoopRunning) return;
             if (!lastTimestamp || screenWidth === 0 || screenHeight === 0 || dynamicBoxWidth === 0) {
                lastTimestamp = timestamp;
                requestAnimationFrame(update);
                return;
             }
             const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000);
             lastTimestamp = timestamp;

             // Passive Gain (Removed)

             // Update streak & reboot preview
             if (gameState.hitStreakCounter > 1 && timestamp - gameState.lastHitTime > HIT_STREAK_WINDOW_MS) { gameState.hitStreakCounter = 0; updateStreakDisplay(); }
             updateRebootPreview();

             // --- MODIFIED: Corner Hit Processing ---
             let cornerHitsThisFrame = 0; // Count *logos* hitting *any* corner this frame
             let cornerHitLocations = []; // Store details of each corner hit this frame
             // --- END MODIFICATION ---

             const currentSpeed = getCurrentSpeed();
             const effectiveBoxWidth = dynamicBoxWidth;
             const effectiveBoxHeight = dynamicBoxHeight;

             gameState.boxes.forEach(box => {
                if (!box.element || isNaN(box.vx) || isNaN(box.vy)) return;

                let boxVX = box.vx; let boxVY = box.vy;

                // Speed normalization
                const speedMagnitude = Math.sqrt(boxVX**2 + boxVY**2);
                if (speedMagnitude > 0.01 && Math.abs(speedMagnitude - currentSpeed) > 0.1) {
                    const scaleFactor = currentSpeed / speedMagnitude;
                    boxVX = (isNaN(scaleFactor) ? 1 : scaleFactor) * boxVX;
                    boxVY = (isNaN(scaleFactor) ? 1 : scaleFactor) * boxVY;
                } else if (speedMagnitude < 0.1 && currentSpeed > 0.1) { // Kickstart
                    const angle = Math.random() * Math.PI * 2;
                    boxVX = Math.cos(angle) * currentSpeed * 0.5;
                    boxVY = Math.sin(angle) * currentSpeed * 0.5;
                }

                // Movement
                let deltaX = boxVX * deltaTime * 60; let deltaY = boxVY * deltaTime * 60;
                deltaX = Math.max(-effectiveBoxWidth * 0.9, Math.min(effectiveBoxWidth * 0.9, deltaX));
                deltaY = Math.max(-effectiveBoxHeight * 0.9, Math.min(effectiveBoxHeight * 0.9, deltaY));
                box.x += deltaX; box.y += deltaY;

                let hitWall = false;

                // Collision Detection & Response
                if (box.x <= 0 && boxVX < 0) { box.x = 0 + Math.random()*0.1; boxVX = Math.abs(boxVX); hitWall = true; }
                else if (box.x >= screenWidth - effectiveBoxWidth && boxVX > 0) { box.x = screenWidth - effectiveBoxWidth - Math.random()*0.1; boxVX = -Math.abs(boxVX); hitWall = true; }
                if (box.y <= 0 && boxVY < 0) { box.y = 0 + Math.random()*0.1; boxVY = Math.abs(boxVY); hitWall = true; }
                else if (box.y >= screenHeight - effectiveBoxHeight && boxVY > 0) { box.y = screenHeight - effectiveBoxHeight - Math.random()*0.1; boxVY = -Math.abs(boxVY); hitWall = true; }

                if (hitWall) {
                    const newColor = getRandomColor();
                    if (box.element) { box.element.style.backgroundColor = newColor; }

                    let scoreFromHit = gameState.hitValue; let isCriticalHit = false;
                    if (Math.random() < gameState.criticalHitChance) {
                         scoreFromHit *= gameState.criticalHitMultiplier; isCriticalHit = true;
                         showCriticalHitEffect(); // Show CRT effect
                         flashBox(box.element, false, true); // Keep the flash
                     }

                    gameState.hitStreakCounter++; gameState.lastHitTime = timestamp;
                    // <<< MODIFIED: Apply base streak bonus >>>
                    const streakMultiplier = 1 + gameState.metaStreakStartBonus + gameState.hitStreakCounter * gameState.streakBonusPerHit;
                    scoreFromHit *= streakMultiplier;
                    addHitScore(Math.ceil(scoreFromHit)); updateStreakDisplay();

                    if (gameState.ricochetChance > 0 && Math.random() < gameState.ricochetChance) { addHitScore(gameState.ricochetBonusHits); }

                    // --- MODIFIED: Corner Hit Detection within Wall Hit ---
                    const cornerThreshold = Math.min(5, effectiveBoxWidth * 0.1, effectiveBoxHeight * 0.1);
                    // Check position *at the time of impact* (or just after bounce adjustment)
                    const isNearLeft = box.x <= cornerThreshold;
                    const isNearRight = box.x >= screenWidth - effectiveBoxWidth - cornerThreshold;
                    const isNearTop = box.y <= cornerThreshold;
                    const isNearBottom = box.y >= screenHeight - effectiveBoxHeight - cornerThreshold;

                    const isPotentialCorner = (isNearLeft && isNearTop) || (isNearRight && isNearTop) || (isNearLeft && isNearBottom) || (isNearRight && isNearBottom);

                    if (isPotentialCorner) {
                        // --- This box hit a corner area THIS FRAME ---
                        cornerHitsThisFrame++; // Increment count of logos hitting corners
                        gameState.hitStreakCounter = 0; updateStreakDisplay(); // Reset streak on corner hit

                        let cornerX = 0, cornerY = 0;
                        if (isNearLeft && isNearTop) { cornerX = 0; cornerY = 0; }
                        else if (isNearRight && isNearTop) { cornerX = screenWidth; cornerY = 0; }
                        else if (isNearLeft && isNearBottom) { cornerX = 0; cornerY = screenHeight; }
                        else if (isNearRight && isNearBottom) { cornerX = screenWidth; cornerY = screenHeight; }

                        let isPerfectCorner = false;
                        if (Math.random() < gameState.perfectCornerChance) {
                             isPerfectCorner = true;
                             // Notification for perfect corner still shown immediately
                             showNotification("Perfect Corner!", true);
                        }

                        // Store details for processing after loop
                        cornerHitLocations.push({ x: cornerX, y: cornerY, isPerfect: isPerfectCorner, boxId: box.id });

                        // Flash the box immediately
                        flashBox(box.element, true, isPerfectCorner);

                        // --- DO NOT ADD SCORE OR SHOW CORNER EFFECT HERE ---

                    } else if (hitWall && !isCriticalHit) {
                        // Optional normal flash for regular wall hit
                        // flashBox(box.element, false, false); // Example if you want a subtle flash
                    }
                    // --- END MODIFIED CORNER DETECTION ---
                }

                box.vx = boxVX; box.vy = boxVY;
                box.x = Math.max(0, Math.min(box.x, screenWidth - effectiveBoxWidth));
                box.y = Math.max(0, Math.min(box.y, screenHeight - effectiveBoxHeight));
                if (box.element) { box.element.style.left = `${box.x}px`; box.element.style.top = `${box.y}px`; }
             });

             // --- MODIFIED: Process Corner Hits AFTER Loop ---
             if (cornerHitLocations.length > 0) {
                 // Get unique corner locations hit this frame
                 const uniqueLocations = [...new Map(cornerHitLocations.map(item => [`${item.x}-${item.y}`, item])).values()];

                 let totalCornerScoreThisFrame = 0;

                 uniqueLocations.forEach(loc => {
                     // Calculate base score for this unique corner hit
                     let score = gameState.cornerHitValue;

                     // <<< NEW: Apply Corner Echo Bonus >>>
                     if (gameState.cornerEchoBonusPercent > 0 && gameState.hitScore > 0) {
                         const echoBonus = Math.floor(gameState.hitScore * gameState.cornerEchoBonusPercent);
                         score += echoBonus;
                     }

                     // Apply perfect bonus if this unique location had a perfect hit
                     if (loc.isPerfect) {
                         score *= gameState.perfectCornerMultiplier;
                     }

                     totalCornerScoreThisFrame += score;

                     // Show effect and particles for each unique corner location hit
                     showCornerHitEffect(); // <<< NEW EFFECT
                     createSparkParticles(loc.x, loc.y, loc.isPerfect);
                 });

                 // Apply Sync Bonus based on total *logos* hitting corners
                 if (cornerHitsThisFrame > 1 && gameState.syncCornerMultiplier > 1) {
                     totalCornerScoreThisFrame *= gameState.syncCornerMultiplier;
                     showNotification(`Sync Bonus! x${gameState.syncCornerMultiplier.toFixed(1)}`);
                 }

                 // Add the final calculated score for all corner hits this frame
                 addCornerScore(Math.ceil(totalCornerScoreThisFrame)); // Handles first hit visibility etc.
             }
             // --- END MODIFIED CORNER PROCESSING ---


             // Save game periodically
             const now = Date.now();
             if (now - lastSaveTime > 5000) {
                 saveGame(); updateAllUpgradeButtons(); lastSaveTime = now;
             }

             requestAnimationFrame(update);
        }

        // --- Score Management & Visibility ---
        function addCornerScore(amount, countForReboot = true) {
             if (amount <= 0 || isNaN(amount)) return;

             // Check if this is the first corner hit (for unlocking elements)
             const wasFirstHit = !gameState.hasHitFirstCorner;
             if (wasFirstHit) {
                 gameState.hasHitFirstCorner = true;
                 checkCornerVisibility(); // Make corner elements visible
                 console.log("First corner hit! Unlocking corner elements.");
                 saveGame(); // Save immediately after unlocking
             }

             // Note: Sync multiplier is now applied *before* calling this function
             gameState.cornerScore += amount;
             if (countForReboot) { gameState.totalCornersThisRun += amount; }

             updateCornerScoreDisplay();
             checkRebootVisibility(); // Check if reboot/fragment display should be shown
             if (amount > 0) updateCornerUpgradeButtons(); // Update buttons if score changed
        }
        function addHitScore(amount) {
            if (amount <= 0 || isNaN(amount)) return;
            gameState.hitScore += amount;
            updateHitScoreDisplay();
            if (amount > 0) updateHitUpgradeButtons();
        }
        function updateCornerScoreDisplay() { if (!cornerScoreElement) return; cornerScoreElement.textContent = `Corners: ${formatScore(Math.floor(gameState.cornerScore))}`; }
        function updateHitScoreDisplay() { if (!hitScoreElement) return; hitScoreElement.textContent = `Hits: ${formatScore(Math.floor(gameState.hitScore))}`; }
        function updateMetaScoreDisplay() { if (!metaScoreElement) return; metaScoreElement.textContent = `Fragments: ${formatScore(Math.floor(gameState.systemFragments))}`; }
        function updateStreakDisplay() {
             if (!streakDisplayElement) return;
             // <<< MODIFIED: Include base streak bonus >>>
             const currentStreakMult = 1 + gameState.metaStreakStartBonus + gameState.hitStreakCounter * gameState.streakBonusPerHit;
             // Show streak only if multiplier > base or counter > 0
             if ((gameState.hitStreakLevel > 0 && gameState.hitStreakCounter > 1) || gameState.metaStreakStartBonus > 0.001) {
                 streakDisplayElement.textContent = `Streak: ${gameState.hitStreakCounter} (x${currentStreakMult.toFixed(2)})`;
                 streakDisplayElement.classList.add('visible');
             } else {
                 streakDisplayElement.classList.remove('visible');
                 // Optional: Show base x1.00 if no streak and no bonus?
                 // streakDisplayElement.textContent = `Streak: 0 (x1.00)`;
             }
        }

        // --- Visibility Control Functions ---
        function checkCornerVisibility() {
            if (!cornerScoreElement || !cornerUpgradesOuterContainerElement) return;
            if (gameState.hasHitFirstCorner) {
                cornerScoreElement.style.display = 'block';
                cornerUpgradesOuterContainerElement.style.display = 'block';
            } else {
                cornerScoreElement.style.display = 'none';
                cornerUpgradesOuterContainerElement.style.display = 'none';
            }
        }

        // --- Helpers ---
        function flashBox(element, isCorner = true, isPerfect = false) {
            if (!element) return;
            let flashClass = '';
            // Determine the flash class based on priority: Perfect > Corner
            if (isPerfect) flashClass = 'perfect-hit-flash';
            else if (isCorner) flashClass = 'corner-hit-flash';

            if (flashClass) {
                element.classList.add(flashClass);
                // Use a slightly longer timeout for perfect flash to match its brightness/importance
                setTimeout(() => {
                    element.classList.remove(flashClass);
                }, isPerfect ? 200 : 120);
            }
        }
        function createSparkParticles(cornerX, cornerY, isPerfect = false) {
            if (!tvScreenElement) return;
            const particleCount = isPerfect ? 15 : 8;
            const particleLifespan = isPerfect ? 800 : 600;
            const particleSpread = isPerfect ? 90 : 60;
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.classList.add('spark-particle');
                particle.style.left = `${cornerX}px`; particle.style.top = `${cornerY}px`;
                particle.style.backgroundColor = isPerfect ? (Math.random() > 0.3 ? 'var(--perfect-hit-color)' : 'var(--spark-color-1)') : (Math.random() > 0.4 ? 'var(--spark-color-1)' : 'var(--spark-color-2)');
                const particleBaseSize = Math.max(2, Math.min(5, dynamicBoxHeight * 0.1));
                particle.style.width = isPerfect ? `${particleBaseSize * 1.3}px` : `${particleBaseSize}px`;
                particle.style.height = isPerfect ? `${particleBaseSize * 1.3}px` : `${particleBaseSize}px`;
                tvScreenElement.appendChild(particle);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * particleSpread;
                let dirX = Math.cos(angle); let dirY = Math.sin(angle);
                if (cornerX < screenWidth / 2) dirX = Math.abs(dirX); else dirX = -Math.abs(dirX);
                if (cornerY < screenHeight / 2) dirY = Math.abs(dirY); else dirY = -Math.abs(dirY);
                const targetX = dirX * distance; const targetY = dirY * distance;
                // Use double requestAnimationFrame for smoother start to transition
                requestAnimationFrame(() => { requestAnimationFrame(() => {
                    particle.style.transform = `translate(${targetX}px, ${targetY}px) scale(${isPerfect ? 0.5 : 1})`;
                    particle.style.opacity = 0;
                }); });
                setTimeout(() => { particle.remove(); }, particleLifespan);
            }
        }
        function checkAndAdjustAllBoxPositions() {
             if (!screenWidth || !screenHeight || !gameState || dynamicBoxWidth === 0) return;
             const effW = dynamicBoxWidth; const effH = dynamicBoxHeight;
             gameState.boxes.forEach(box => {
                 box.x = Math.max(0, Math.min(box.x ?? 50, screenWidth - effW));
                 box.y = Math.max(0, Math.min(box.y ?? 50, screenHeight - effH));
                 if(box.element){ box.element.style.left = `${box.x}px`; box.element.style.top = `${box.y}px`; }
             });
        }
        function showNotification(message, isImportant = false) {
            if (!notificationElement) return;
            notificationElement.textContent = message;
            notificationElement.className = 'show'; // Use className to reset classes
            if (isImportant) { notificationElement.classList.add('perfect'); }
            if (notificationElement.timer) clearTimeout(notificationElement.timer);
            notificationElement.timer = setTimeout(() => {
                 notificationElement.className = ''; notificationElement.timer = null;
             }, isImportant ? 3500 : 2500);
        }
        // --- Critical Hit Effect ---
        function showCriticalHitEffect() {
            if (!tvScreenElement) return;
            const critText = document.createElement('div');
            critText.classList.add('critical-hit-text');
            critText.textContent = "CRITICAL";
            tvScreenElement.appendChild(critText);

            // Remove the element after the animation finishes (duration is 1.2s from CSS)
            setTimeout(() => {
                critText.remove();
            }, 1200);
        }
        // --- NEW: Corner Hit Effect ---
        function showCornerHitEffect() {
             if (!tvScreenElement) return;
             const cornerText = document.createElement('div');
             cornerText.classList.add('corner-hit-text');
             cornerText.textContent = "CORNER HIT";
             tvScreenElement.appendChild(cornerText);

             // Remove the element after the animation finishes (duration is 1.0s from CSS)
             setTimeout(() => {
                 cornerText.remove();
             }, 1000);
        }
        function formatScore(value) {
            const V = Math.floor(value);
            if (V < 1e4) return V.toString(); if (V < 1e6) return (V / 1e3).toFixed(1) + 'K';
            if (V < 1e9) return (V / 1e6).toFixed(1) + 'M'; if (V < 1e12) return (V / 1e9).toFixed(1) + 'B';
            if (V < 1e15) return (V / 1e12).toFixed(1) + 'T'; if (V < 1e18) return (V / 1e15).toFixed(1) + 'Qd';
            return (V / 1e18).toFixed(1) + 'Qn';
         }

        // --- Upgrade Rendering & Buying ---
        function renderUpgradeSection(upgrades, container, currencyType) {
            if (!container) return; container.innerHTML = '';
            upgrades.forEach(upgrade => {
                const level = upgrade.getLevel();
                const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor);
                const btn = document.createElement('button');
                btn.classList.add('upgrade-button');
                btn.dataset.upgradeId = upgrade.id; btn.dataset.currencyType = currencyType;
                if (level >= upgrade.maxLevel) {
                    btn.disabled = true;
                    btn.innerHTML = `${upgrade.name}<br>(Max Lv ${level})`;
                } else {
                    btn.innerHTML = upgrade.getDescription(level, cost);
                    let currentScore;
                    if (currencyType === 'corner') currentScore = gameState.cornerScore;
                    else if (currencyType === 'hit') currentScore = gameState.hitScore;
                    else if (currencyType === 'meta') currentScore = gameState.systemFragments;
                    btn.disabled = Math.floor(currentScore) < cost;
                    btn.onclick = () => buyUpgrade(upgrade.id, currencyType);
                } container.appendChild(btn);
            });
         }
        function updateUpgradeButtonsInSection(upgrades, container, currencyType) {
             if (!container) return;
             let currentScore;
             if (currencyType === 'corner') currentScore = gameState.cornerScore;
             else if (currencyType === 'hit') currentScore = gameState.hitScore;
             else if (currencyType === 'meta') currentScore = gameState.systemFragments;

             // Special check for corner upgrades: only enable if corners are visible
             const cornersVisible = gameState.hasHitFirstCorner;

             upgrades.forEach(upgrade => {
                 const btn = container.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
                 if (btn && !btn.textContent.includes('(Max Lv')) { // Only update if not maxed
                     const level = upgrade.getLevel();
                     if (level < upgrade.maxLevel) {
                         const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor);
                         // Disable based on cost OR if it's a corner upgrade and corners aren't visible yet
                         btn.disabled = (Math.floor(currentScore) < cost) || (currencyType === 'corner' && !cornersVisible);
                         // <<< Update description text on button in case derived stats changed (e.g., from meta) >>>
                         btn.innerHTML = upgrade.getDescription(level, cost);
                     } else {
                          btn.disabled = true;
                          btn.innerHTML = `${upgrade.name}<br>(Max Lv ${level})`;
                          btn.onclick = null;
                     }
                 } else if (btn && btn.textContent.includes('(Max Lv')) {
                     // Also update maxed out button descriptions if necessary (unlikely but good practice)
                     const level = upgrade.getLevel();
                     btn.innerHTML = upgrade.getDescription(level, 0); // Pass 0 cost, it won't be shown anyway
                 }
             });
         }
        function renderSingleUpgrade(id, currencyType) {
             const upgrades = (currencyType === 'corner') ? cornerUpgrades : (currencyType === 'hit') ? hitUpgrades : metaUpgrades;
             const container = (currencyType === 'corner') ? cornerUpgradesContainer : (currencyType === 'hit') ? hitUpgradesContainer : metaUpgradesContainer;
             if (!container) return;
             const upgrade = upgrades.find(u => u.id === id);
             const btn = container.querySelector(`[data-upgrade-id="${id}"]`);
             if (!upgrade || !btn) return;
             const level = upgrade.getLevel();
             const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor);
             if (level >= upgrade.maxLevel) {
                 btn.disabled = true;
                 btn.innerHTML = `${upgrade.name}<br>(Max Lv ${level})`;
                 btn.onclick = null;
             } else {
                 btn.innerHTML = upgrade.getDescription(level, cost);
                 let currentScore;
                 if (currencyType === 'corner') currentScore = gameState.cornerScore;
                 else if (currencyType === 'hit') currentScore = gameState.hitScore;
                 else if (currencyType === 'meta') currentScore = gameState.systemFragments;
                 const cornersVisible = gameState.hasHitFirstCorner;
                 btn.disabled = (Math.floor(currentScore) < cost) || (currencyType === 'corner' && !cornersVisible);
                 if (!btn.onclick) { // Re-attach onclick if it was removed
                     btn.onclick = () => buyUpgrade(upgrade.id, currencyType);
                 }
             }
         }
        function buyUpgrade(id, currencyType) {
            const upgrades = (currencyType === 'corner') ? cornerUpgrades : (currencyType === 'hit') ? hitUpgrades : metaUpgrades;
            const upgrade = upgrades.find(u => u.id === id);
            if (!upgrade) return;
            const level = upgrade.getLevel();
            if (level >= upgrade.maxLevel) return;
            const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor);
            let scoreRef;
            if (currencyType === 'corner') scoreRef = 'cornerScore';
            else if (currencyType === 'hit') scoreRef = 'hitScore';
            else if (currencyType === 'meta') scoreRef = 'systemFragments';

            // Prevent buying corner upgrades if corners aren't visible yet (redundant check)
            if (currencyType === 'corner' && !gameState.hasHitFirstCorner) return;

            if (Math.floor(gameState[scoreRef]) >= cost) {
                gameState[scoreRef] -= cost;
                upgrade.applyEffect(); // This increments the level internally now
                if (currencyType === 'corner') updateCornerScoreDisplay();
                else if (currencyType === 'hit') updateHitScoreDisplay();
                else if (currencyType === 'meta') updateMetaScoreDisplay();
                renderSingleUpgrade(id, currencyType); // Update just the bought button
                updateAllUpgradeButtons(); // Update all buttons for affordability changes & potential description updates
                saveGame();
            }
        }
        function renderAllUpgrades() {
             renderUpgradeSection(cornerUpgrades, cornerUpgradesContainer, 'corner');
             renderUpgradeSection(hitUpgrades, hitUpgradesContainer, 'hit');
             renderUpgradeSection(metaUpgrades, metaUpgradesContainer, 'meta');
        }
        function updateAllUpgradeButtons() {
            updateUpgradeButtonsInSection(cornerUpgrades, cornerUpgradesContainer, 'corner');
            updateUpgradeButtonsInSection(hitUpgrades, hitUpgradesContainer, 'hit');
            updateUpgradeButtonsInSection(metaUpgrades, metaUpgradesContainer, 'meta');
        }
        function updateCornerUpgradeButtons() { updateUpgradeButtonsInSection(cornerUpgrades, cornerUpgradesContainer, 'corner'); }
        function updateHitUpgradeButtons(){ updateUpgradeButtonsInSection(hitUpgrades, hitUpgradesContainer, 'hit'); }
        function updateMetaUpgradeButtons(){ updateUpgradeButtonsInSection(metaUpgrades, metaUpgradesContainer, 'meta'); }


        // --- Reboot (Prestige) Logic ---
        function checkRebootVisibility() {
             if (!rebootSectionElement || !metaScoreRowElement || !metaUpgradesOuterContainer) return;

             const showRebootCondition = gameState.hasHitFirstCorner && (gameState.totalCornersThisRun >= REBOOT_CORNER_THRESHOLD || gameState.systemFragments > 0);
             // <<< MODIFIED: Also check new meta upgrade levels for visibility >>>
             const showMetaUpgradesCondition = gameState.hasEarnedFirstFragment || gameState.metaSpeedLevel > 0 || gameState.metaFragmentGainLevel > 0 || gameState.metaStartCornerMultLevel > 0 || gameState.metaStartHitMultLevel > 0 || gameState.metaStreakStartLevel > 0 || gameState.metaCritPowerLevel > 0;

             // Control Reboot Section visibility
             if (showRebootCondition) {
                 rebootSectionElement.style.display = 'block';
             } else {
                 rebootSectionElement.style.display = 'none';
             }

             // Control Fragment Score Row visibility (Show if Reboot is shown OR if fragments have ever been earned)
             if (showRebootCondition || gameState.hasEarnedFirstFragment) {
                metaScoreRowElement.style.display = 'flex';
             } else {
                metaScoreRowElement.style.display = 'none';
             }

             // Control Meta Upgrades container visibility
             if (showMetaUpgradesCondition) {
                 metaUpgradesOuterContainer.style.display = 'block';
             } else {
                 metaUpgradesOuterContainer.style.display = 'none';
             }
        }
        function updateRebootPreview() {
            if (!rebootGainPreviewElement || !rebootSectionElement || rebootSectionElement.style.display === 'none') return;
            const gain = calculateFragmentGain(gameState.totalCornersThisRun);
            rebootGainPreviewElement.textContent = `You will gain ~${formatScore(gain)} Fragments on Reboot.`;
            rebootButtonElement.disabled = gain <= 0; // Disable if no fragments would be gained
        }
        function executeReboot() {
            const fragmentsGained = calculateFragmentGain(gameState.totalCornersThisRun);
            if (fragmentsGained <= 0) {
                showNotification("Not enough progress for fragments yet!");
                return;
            }

            if (!confirm(`Are you sure you want to Reboot? You will gain ${formatScore(fragmentsGained)} System Fragments and reset current progress, but keep Meta Upgrades.`)) {
                return;
            }

            console.log(`Rebooting! Gained ${fragmentsGained} fragments.`);
            showNotification(`System Rebooted! +${formatScore(fragmentsGained)} Fragments!`, true);

            // Check if this is the first time earning fragments
            const wasFirstFragmentEarn = !gameState.hasEarnedFirstFragment;
            if (wasFirstFragmentEarn) {
                gameState.hasEarnedFirstFragment = true;
                console.log("First fragments earned! Unlocking fragment display permanently.");
            }

            // Store persistent values
            const currentFragments = gameState.systemFragments;
            const metaLevels = {
                metaStartCornerMultLevel: gameState.metaStartCornerMultLevel,
                metaStartHitMultLevel: gameState.metaStartHitMultLevel,
                metaFragmentGainLevel: gameState.metaFragmentGainLevel,
                metaSpeedLevel: gameState.metaSpeedLevel,
                // <<< Add new meta levels >>>
                metaStreakStartLevel: gameState.metaStreakStartLevel,
                metaCritPowerLevel: gameState.metaCritPowerLevel,
            };
            // Store flags that should persist
            const persistentFlags = {
                 hasHitFirstCorner: gameState.hasHitFirstCorner, // Corner unlock persists
                 hasEarnedFirstFragment: gameState.hasEarnedFirstFragment // Fragment unlock persists
            };

            // Reset game state (gets fresh defaults)
            gameState = createDefaultGameState();

            // Restore persistent values
            gameState.systemFragments = currentFragments + fragmentsGained;
            Object.assign(gameState, metaLevels); // Restore meta levels
            Object.assign(gameState, persistentFlags); // Restore flags

            // Remove Overcharge visual on reboot
            tvFrameElement?.classList.remove('overcharged');

            // Recalculate derived state based on restored meta levels
            recalculateDerivedState();

            // Update UI
            updateCornerScoreDisplay();
            updateHitScoreDisplay();
            updateMetaScoreDisplay();
            updateStreakDisplay();
            renderAllUpgrades(); // Re-render all upgrades to reflect reset levels
            updateAllUpgradeButtons(); // Crucial to update button states and descriptions after recalc
            checkRebootVisibility(); // Update visibility of reboot/meta/fragment sections
            checkCornerVisibility(); // Ensure corner elements remain visible if flag is true
            updateRebootPreview();

            // Reset visuals
            removeAllBoxes();
            addBox(true); // Add one box back in the center

            saveGame(); // Save the new state immediately after reboot
        }


        // --- Saving and Loading ---
        function saveGame() {
            try {
                // Ensure streak counter is reset if window expired
                if (Date.now() - gameState.lastHitTime > HIT_STREAK_WINDOW_MS) { gameState.hitStreakCounter = 0; }
                // Create save object, excluding DOM elements
                const stateToSave = { ...gameState, boxes: gameState.boxes.map(({ element, ...rest }) => rest) };
                const saveData = JSON.stringify(stateToSave);
                localStorage.setItem(SAVE_KEY, saveData);
                 // console.log("Game saved:", SAVE_VERSION); // Optional debug log
            } catch (e) { console.error("Failed to save game:", e); showNotification("Error saving game!"); }
        }
        function loadGame() {
            const savedData = localStorage.getItem(SAVE_KEY);
            let needsInitialization = true;
            if (savedData) {
                try {
                    const loadedState = JSON.parse(savedData);
                    // Basic validation - check core fields and flags
                    if (typeof loadedState.cornerScore === 'number' && typeof loadedState.hitScore === 'number' &&
                        typeof loadedState.systemFragments === 'number' && Array.isArray(loadedState.boxes) &&
                        typeof loadedState.hasHitFirstCorner === 'boolean' && typeof loadedState.hasEarnedFirstFragment === 'boolean') {

                        // Use deep merge, ensuring defaults exist for any missing loaded fields
                        gameState = deepMerge(createDefaultGameState(), loadedState);

                        // Post-load cleanup/validation
                        if (Date.now() - gameState.lastHitTime > HIT_STREAK_WINDOW_MS) { gameState.hitStreakCounter = 0; }
                        gameState.boxes = gameState.boxes.filter(b => b && typeof b.x === 'number' && typeof b.y === 'number'); // Filter invalid boxes

                        recalculateDerivedState(); // Apply loaded levels to derived stats
                        console.log("Game loaded:", SAVE_VERSION);
                        showNotification("Game Loaded");
                        needsInitialization = false;
                    } else {
                        console.warn("Invalid or outdated save data structure for", SAVE_VERSION, ". Resetting.");
                        localStorage.removeItem(SAVE_KEY); // Remove invalid save
                    }
                } catch (e) {
                    console.error("Failed to parse or load game:", e);
                    showNotification("Error loading save data! Resetting.");
                    localStorage.removeItem(SAVE_KEY); // Remove corrupted save
                }
            }
            // Initialize if no save or load failed
            if (needsInitialization) {
                console.log("Initializing new game state:", SAVE_VERSION);
                gameState = createDefaultGameState();
                recalculateDerivedState(); // Calculate initial derived stats
            }
            return needsInitialization; // Return true if a new game was started
        }
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
        function deepMerge(target, source) { // Simple deep merge
            let output = { ...target };
            if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach(key => {
                    if (isObject(source[key])) {
                        if (!(key in target)) {
                            Object.assign(output, { [key]: source[key] });
                        } else {
                            output[key] = deepMerge(target[key], source[key]);
                        }
                    } else {
                         // Only assign if the key exists in the default target OR is a standard expected key
                         const expectedKeys = [
                            'cornerScore', 'hitScore', 'systemFragments', 'boxes', 'totalCornersThisRun',
                            'cornerMultiplierLevel', 'multiBoxLevel', 'syncBonusLevel', 'speedLevelHits', 'hitValueLevel',
                            'hitStreakLevel', 'ricochetLevel', 'perfectCornerLevel', 'criticalHitLevel', 'precisionTuningLevel',
                            'momentumDriveLevel', 'cornerEchoLevel', // Added cornerEchoLevel
                            'metaStartCornerMultLevel', 'metaStartHitMultLevel',
                            'metaFragmentGainLevel', 'metaSpeedLevel', 'metaStreakStartLevel', 'metaCritPowerLevel', // Added new meta levels
                            'cornerHitValue', 'hitValue', 'baseSpeed', 'baseSpeedHits',
                            'syncCornerMultiplier', 'streakBonusPerHit', 'ricochetChance', 'ricochetBonusHits', 'perfectCornerChance',
                            'perfectCornerMultiplier', 'criticalHitChance', 'criticalHitMultiplier',
                            'cornerEchoBonusPercent', // Added derived state
                            'metaFragmentMultiplier', 'metaSpeedBoost', 'metaStreakStartBonus', 'metaCritPowerBonus', // Added derived meta states
                            'hitStreakCounter', 'lastHitTime',
                            'hasHitFirstCorner', 'hasEarnedFirstFragment' // Include flags
                         ];
                         if (key in target || expectedKeys.includes(key)) {
                            Object.assign(output, { [key]: source[key] });
                         } else {
                            // console.warn(`Skipping unexpected key "${key}" during deepMerge.`); // Optional warning
                         }
                    }
                });
            }
            return output;
         }
        function createDefaultGameState() {
             // Define ALL state variables here
             return {
                 // Scores
                 cornerScore: 0, hitScore: 0, systemFragments: 0, totalCornersThisRun: 0,
                 // Boxes
                 boxes: [],
                 // Standard Upgrade Levels
                 cornerMultiplierLevel: 0, multiBoxLevel: 0, syncBonusLevel: 0,
                 speedLevelHits: 0, hitValueLevel: 0, hitStreakLevel: 0, ricochetLevel: 0,
                 perfectCornerLevel: 0, criticalHitLevel: 0,
                 precisionTuningLevel: 0, momentumDriveLevel: 0, cornerEchoLevel: 0, // Added new corner upgrade level
                 // Meta Upgrade Levels
                 metaStartCornerMultLevel: 0, metaStartHitMultLevel: 0, metaFragmentGainLevel: 0, metaSpeedLevel: 0,
                 metaStreakStartLevel: 0, metaCritPowerLevel: 0, // Added new meta upgrade levels
                 // Derived Stats (will be calculated, but good to have defaults)
                 cornerHitValue: 1, hitValue: 1, baseSpeed: 1, baseSpeedHits: 1,
                 syncCornerMultiplier: 1, streakBonusPerHit: 0,
                 ricochetChance: 0, ricochetBonusHits: 0,
                 perfectCornerChance: 0, perfectCornerMultiplier: 1,
                 criticalHitChance: 0, criticalHitMultiplier: 1,
                 cornerEchoBonusPercent: 0, // Added derived state
                 // Meta Derived Stats
                 metaFragmentMultiplier: 1, metaSpeedBoost: 1,
                 metaStreakStartBonus: 0, metaCritPowerBonus: 0, // Added derived meta states
                 // Timers/Counters
                 hitStreakCounter: 0, lastHitTime: 0,
                 // Visibility Flags
                 hasHitFirstCorner: false,
                 hasEarnedFirstFragment: false,
             };
        }

        // --- Derivation Functions ---
        function deriveCornerValue(level) {
            const baseValue = 1 + level + Math.floor(level / 3);
            const metaBoost = deriveMetaStartCornerMult(gameState.metaStartCornerMultLevel);
            const momentumBoost = deriveMomentumCornerBoost(gameState.momentumDriveLevel);
            return Math.max(1, Math.floor((baseValue + metaBoost) * (1 + momentumBoost)));
        }
         function deriveHitValue(level) {
             const baseValue = 1 + level;
             const metaBoost = deriveMetaStartHitMult(gameState.metaStartHitMultLevel);
             const precisionBoost = derivePrecisionHitBoost(gameState.precisionTuningLevel);
             return Math.max(1, Math.floor((baseValue + metaBoost) * (1 + precisionBoost)));
         }
         function derivePerfectCornerStats(level) { // Returns [chance %, multiplier]
             const chance = Math.min(25, level * 0.8); // Max 25% chance
             const multiplier = 3 + Math.floor(level / 2); // Starts at x3, increases
             return [chance, multiplier];
         }
         function deriveCriticalHitStats(level) { // Returns [chance %, multiplier]
              const chance = Math.min(30, level * 1.0); // Max 30% chance
              const baseMultiplier = 2 + Math.floor(level / 2); // Starts at x2, increases
              // <<< MODIFIED: Add meta crit power bonus >>>
              const finalMultiplier = baseMultiplier + gameState.metaCritPowerBonus;
              return [chance, finalMultiplier];
         }
         function derivePrecisionHitBoost(level) { return level * 0.02; } // +2% base hit value per level
         function deriveMomentumCornerBoost(level) { return level * 0.015; } // +1.5% base corner value per level
         function deriveSyncBonus(level) { return 1 + level * 0.5; }
         function deriveSpeedFromHits(level) { return Math.pow(1.15, level); }
         function deriveStreakBonusPerHit(level) { return level * 0.005; } // +0.5% per hit in streak per level
         function deriveRicochetStats(level) { // Returns [chance %, bonus hits]
             const chance = Math.min(50, 1 + level * 2);
             const bonus = 1 + Math.floor(level / 2);
             return [chance, bonus];
         }
         // <<< NEW: Corner Echo Derivation >>>
         function deriveCornerEchoBonus(level) { return level * 0.005; } // +0.5% of hits per level

         // Meta Derivations
         function deriveMetaStartCornerMult(level) { return level * 2; } // +2 base corner value per level
         function deriveMetaStartHitMult(level) { return level * 1; } // +1 base hit value per level
         function deriveMetaFragmentMult(level) { return 1 + level * 0.1; } // +10% fragments per level
         function deriveMetaSpeedBoost(level) { return 1 + level * 0.05; } // +5% speed per level
         // <<< NEW: Meta Streak Start Derivation >>>
         function deriveMetaStreakStartBonus(level) { return level * 0.02; } // +0.02 base multiplier per level
         // <<< NEW: Meta Crit Power Derivation >>>
         function deriveMetaCritPowerBonus(level) { return level * 0.25; } // +0.25x crit multiplier per level

        function recalculateDerivedState() { // Central place to update calculated stats
             if (!gameState) return;
             // Calculate Meta bonuses first as they might affect others
             gameState.metaFragmentMultiplier = deriveMetaFragmentMult(gameState.metaFragmentGainLevel);
             gameState.metaSpeedBoost = deriveMetaSpeedBoost(gameState.metaSpeedLevel);
             gameState.metaStreakStartBonus = deriveMetaStreakStartBonus(gameState.metaStreakStartLevel);
             gameState.metaCritPowerBonus = deriveMetaCritPowerBonus(gameState.metaCritPowerLevel);

             // Regular derived stats
             gameState.cornerHitValue = deriveCornerValue(gameState.cornerMultiplierLevel);
             gameState.hitValue = deriveHitValue(gameState.hitValueLevel);
             [gameState.perfectCornerChance, gameState.perfectCornerMultiplier] = derivePerfectCornerStats(gameState.perfectCornerLevel);
             gameState.perfectCornerChance /= 100; // Convert % to decimal
             [gameState.criticalHitChance, gameState.criticalHitMultiplier] = deriveCriticalHitStats(gameState.criticalHitLevel);
             gameState.criticalHitChance /= 100; // Convert % to decimal
             gameState.syncCornerMultiplier = deriveSyncBonus(gameState.syncBonusLevel);
             gameState.baseSpeedHits = deriveSpeedFromHits(gameState.speedLevelHits);
             gameState.streakBonusPerHit = deriveStreakBonusPerHit(gameState.hitStreakLevel);
             [gameState.ricochetChance, gameState.ricochetBonusHits] = deriveRicochetStats(gameState.ricochetLevel);
             gameState.ricochetChance /= 100; // Convert % to decimal
             gameState.cornerEchoBonusPercent = deriveCornerEchoBonus(gameState.cornerEchoLevel);

             // Recalculate total speed (now depends on metaSpeedBoost)
             gameState.baseSpeed = 1; // Reset base speed (if it's not meant to be upgradeable)

             // console.log("Recalculated derived state."); // Optional debug log

             // Update UI elements that depend on derived stats immediately
             updateStreakDisplay(); // Streak display depends on meta bonus now
        }

        function recreateBoxElements() { // Rebuilds DOM elements for boxes after load
             if (!tvScreenElement) { console.error("tvScreenElement missing in recreateBoxElements"); return; }
             tvScreenElement.querySelectorAll('.box').forEach(el => el.remove()); // Clear only boxes
             nextBoxId = 0;
             gameState.boxes = gameState.boxes.filter(boxData => boxData && typeof boxData.x === 'number'); // Basic validation
             gameState.boxes.forEach((boxData) => {
                 boxData.id = getNextBoxId();
                 boxData.element = createBoxElement(boxData.id);
                 if (boxData.element) {
                     // Use saved position, clamped to current screen dimensions and *dynamic* box size
                     boxData.x = Math.max(0, Math.min(boxData.x, (screenWidth || 300) - dynamicBoxWidth));
                     boxData.y = Math.max(0, Math.min(boxData.y, (screenHeight || 200) - dynamicBoxHeight));
                     boxData.element.style.left = `${boxData.x}px`;
                     boxData.element.style.top = `${boxData.y}px`;
                     boxData.element.style.backgroundColor = '#ffffff'; // Reset color on load
                     // Validate velocity, reset if needed
                     if(isNaN(boxData.vx) || isNaN(boxData.vy) || Math.sqrt(boxData.vx**2 + boxData.vy**2) < 0.1) {
                        const angle = Math.random() * Math.PI * 2;
                        const startSpeed = Math.max(0.5, getCurrentSpeed() * 0.6);
                        boxData.vx = Math.cos(angle) * startSpeed;
                        boxData.vy = Math.sin(angle) * startSpeed;
                     }
                 } else { console.error(`Failed element create ID ${boxData.id} on load.`); }
             });
             console.log(`Recreated ${gameState.boxes.length} box elements.`);
        }

        // --- Initialization and Resize ---
        function handleResize() {
            const rect = tvScreenElement?.getBoundingClientRect();
            if (!rect || rect.width <= 0 || rect.height <= 0) return; // Ignore invalid rect

            // Only update if size significantly changed
            if (Math.abs(screenWidth - rect.width) > 1 || Math.abs(screenHeight - rect.height) > 1) {
                 screenWidth = rect.width;
                 screenHeight = rect.height;

                 // --- Calculate Dynamic Logo Size ---
                 dynamicBoxHeight = Math.max(15, screenHeight * LOGO_HEIGHT_SCREEN_RATIO);
                 dynamicBoxWidth = dynamicBoxHeight * BOX_ASPECT_RATIO;

                 // Update CSS variables
                 document.documentElement.style.setProperty('--logo-dynamic-height', `${dynamicBoxHeight}px`);
                 document.documentElement.style.setProperty('--logo-dynamic-width', `${dynamicBoxWidth}px`);

                 console.log(`Resized screen: ${screenWidth.toFixed(0)}x${screenHeight.toFixed(0)}, Logo: ${dynamicBoxWidth.toFixed(1)}x${dynamicBoxHeight.toFixed(1)}`);

                 checkAndAdjustAllBoxPositions(); // Adjust existing boxes to new bounds/size
                 if (!gameLoopRunning && screenWidth > 0 && screenHeight > 0) {
                    startGameLoop();
                 }
            }
         }
        function startGameLoop() {
            if (gameLoopRunning) return;
            if (screenWidth > 0 && screenHeight > 0 && tvScreenElement) {
                console.log("Starting game loop...");
                gameLoopRunning = true;
                lastTimestamp = performance.now(); // Initialize timestamp
                requestAnimationFrame(update);
            } else { console.log("Deferring game loop start (screen size unknown)."); }
         }

        function init() {
             // Check essential elements exist
             if (!tvScreenElement || !cornerScoreElement || !hitScoreElement || !metaScoreElement || !streakDisplayElement || !cornerUpgradesContainer || !hitUpgradesContainer || !metaUpgradesContainer || !notificationElement || !rebootSectionElement || !rebootButtonElement || !metaUpgradesOuterContainer || !metaScoreRowElement || !cornerUpgradesOuterContainerElement) {
                 console.error("Essential DOM elements are missing. Cannot initialize.");
                 document.body.innerHTML = "<p style='color:red; text-align:center; padding: 20px;'>Error: Could not find essential game elements. Please check the HTML structure.</p>";
                 return;
             }
             console.log("Initializing game", SAVE_VERSION, "...");

             const isNewGame = loadGame(); // Load or initialize gameState (calls recalculateDerivedState)

             // Initial UI setup based on loaded/new state
             updateCornerScoreDisplay();
             updateHitScoreDisplay();
             updateMetaScoreDisplay();
             // updateStreakDisplay(); // Already called by recalculateDerivedState inside loadGame/createDefault
             renderAllUpgrades();

             // Set initial visibility based on loaded flags
             checkCornerVisibility();
             checkRebootVisibility(); // Handles Reboot, Fragment Score Row, and Meta Upgrades Container

             updateAllUpgradeButtons(); // Set initial button states (now considers visibility and recalculated stats)
             updateRebootPreview(); // Update fragment gain preview

             // Remove overcharge class if loaded state doesn't have it (it's not persisted)
             // tvFrameElement?.classList.remove('overcharged'); // Done in executeReboot and not applied on load

             // Handle resize *before* creating/recreating boxes to get initial size
             handleResize();
             window.addEventListener('resize', handleResize);

             if (!isNewGame) {
                 recreateBoxElements(); // Rebuild DOM elements from saved state using correct dynamic size
             }

             // Add initial box if needed (new game OR loaded game with no boxes)
             if (gameState.boxes.length === 0) {
                // Use a small delay to ensure layout/size calculation is complete
                setTimeout(() => {
                    const currentRect = tvScreenElement?.getBoundingClientRect();
                    if(currentRect && currentRect.width > 0 && currentRect.height > 0) {
                       if (Math.abs(screenWidth - currentRect.width) > 1 || Math.abs(screenHeight - currentRect.height) > 1) {
                            handleResize(); // Call resize again if needed
                       }
                    }
                    if (screenWidth > 0 && screenHeight > 0 && gameState.boxes.length === 0) {
                        console.log("Adding initial logo (deferred).");
                        addBox(true); // Pass true for center spawn
                    } else if (gameState.boxes.length === 0) {
                         console.warn("Could not add initial logo - screen size still 0 after delay?");
                    }
                }, 100); // 100ms delay
             }

             // Add event listener for reboot button
             rebootButtonElement.onclick = executeReboot;

             startGameLoop(); // Attempt to start game loop
             lastSaveTime = Date.now(); // Set initial save time
        }

        // --- Start ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
             init(); // Already loaded
        }

    })(); // End of IIFE
</script>

</body>
</html>
