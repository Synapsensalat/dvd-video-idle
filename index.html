<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DVD Video Idle</title>
    <style>
        :root {
            --tv-bg: #282828;
            --screen-bg: #111;
            --text-color: #eee;
            --border-color: #444;
            --highlight-color-hits: #0df; /* Teal */
            --highlight-color-corners: #0f0; /* Still used for text color */
            --highlight-color-wall: #0df;
            --meta-color: #f0f; /* Pink */
            --collision-color: #f90;
            --screen-burn-color: #ff4500; /* OrangeRed for burn */
            --tv-hover-light: #f50;
            --tv-upgrade-light: var(--highlight-color-hits);
            --modal-bg-translucent: rgba(25, 25, 25, 0.92);
            --modal-border: #555;
            --button-bg: #4a4a4a;
            --button-hover: #666;
            --button-active: #777;
            --disabled-color: #777;
            --accent-color: #eee;
            --main-bg-color: #000;
            --corner-bet-color: #ffd700; /* Gold */
            --win-color: #2f2; /* Bright Green */
            --loss-color: #f44; /* Bright Red */
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--main-bg-color);
            font-family: 'Courier New', Courier, monospace; color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
            opacity: 1;
        }

        #loading-screen .loading-logo-container {
            width: 50%;
            max-width: 350px;
            aspect-ratio: 960 / 500;
            margin-bottom: 20px;
            background-color: var(--highlight-color-hits);
            mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            mask-position: center;
            -webkit-mask-position: center;
        }
        #loading-screen .loading-logo-container img {
            opacity: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #loading-screen .loading-text {
            font-family: 'Futura Medium', Futura, 'Century Gothic', AppleGothic, sans-serif;
            font-size: clamp(3rem, 10vw, 5rem);
            color: var(--meta-color);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .hidden {
            display: none !important;
        }
        /* --- End Loading Screen Styles --- */


        #game-container {
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            width: 100%; height: 100%; padding: 10px; box-sizing: border-box; position: relative;
        }

        #top-info-bar {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: center; align-items: center;
            gap: 20px;
            z-index: 10; pointer-events: none;
            flex-wrap: wrap;
        }
        .top-info-display {
            font-size: clamp(1.1rem, 2.5vw, 1.6rem); font-weight: bold;
            background-color: rgba(10, 10, 10, 0.6); padding: 3px 10px;
            border-radius: 5px; flex-shrink: 0; text-align: center;
        }
        #total-hits-display {
            color: var(--highlight-color-hits);
            text-shadow: 0 0 5px var(--highlight-color-hits);
        }

        #tvs-display-area {
            display: flex; flex-wrap: wrap; justify-content: center;
            align-items: flex-start;
            gap: 15px;
            width: 100%; max-width: 1400px;
            padding: 15px; box-sizing: border-box;
            margin-top: 65px;
            max-height: calc(100vh - 110px); /* Adjusted for potential top/bottom buttons */
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tv-instance-container {
            display: flex; flex-direction: column; align-items: center;
            width: clamp(300px, 35vw, 420px);
            flex-shrink: 0; position: relative;
        }

        .tv-frame {
            background-image: url('https://00s.myretrotvs.com/img/tvbackclean.webp');
            background-size: 100% calc(100% / 0.84);
            background-position: center top;
            background-repeat: no-repeat;
            position: relative;
            width: 100%;
            aspect-ratio: 1.25 / 0.84;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        .tv-screen {
            position: absolute;
            top: 9.4%;
            height: 74.1%;
            left: 12%;
            width: 76%;
            background-color: var(--screen-bg);
            overflow: hidden;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            filter: url(#crt-effect);
        }

        .tv-screen::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.20) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.04), rgba(0, 255, 0, 0.015), rgba(0, 0, 255, 0.04)); background-size: 100% 2px, 3px 100%; z-index: 2; pointer-events: none; animation: crt-scanline 100s linear infinite; }
        @keyframes crt-scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        .box {
            position: absolute;
            background-color: #ffffff;
            mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            mask-size: contain; -webkit-mask-size: contain;
            mask-repeat: no-repeat; -webkit-mask-repeat: no-repeat;
            mask-position: center; -webkit-mask-position: center;
            z-index: 1;
            filter: brightness(1.05);
            will-change: transform, filter, box-shadow;
            transition: filter 0.2s ease, box-shadow 0.2s ease;
            /* CSS variables for transform base, used by JS and shake animation */
            transform: translate(var(--tx, 0px), var(--ty, 0px));
         }

        /* --- START: Screen Burn Effect --- */
        .box.screen-burn-effect {
            filter: brightness(1.4) saturate(1.8);
            box-shadow: 0 0 8px 4px var(--screen-burn-color),
                        inset 0 0 4px rgba(255, 100, 50, 0.8);
            animation: screenBurnPulse 0.8s infinite alternate ease-in-out;
            z-index: 5; /* Bring burning logos slightly forward */
        }
        @keyframes screenBurnPulse {
            0% { filter: brightness(1.4) saturate(1.8); box-shadow: 0 0 8px 4px var(--screen-burn-color), inset 0 0 4px rgba(255, 100, 50, 0.8); }
            100% { filter: brightness(1.6) saturate(2.2); box-shadow: 0 0 12px 6px var(--screen-burn-color), inset 0 0 6px rgba(255, 120, 70, 0.9); }
        }
        /* --- END: Screen Burn Effect --- */

        /* --- START: Logo Shake Effect --- */
        /* This class is added/removed by JS during screen burn */
        .logo-shake {
            /* Apply animation ON TOP of the base transform set by --tx and --ty */
            animation: logoShakeAnim 0.3s ease-in-out 1; /* Play once per application */
        }
        @keyframes logoShakeAnim {
            /* These translate values are ADDED to the base transform */
            0%, 100% { transform: translate(var(--tx, 0px), var(--ty, 0px)) translate(0, 0) rotate(0); }
            25% { transform: translate(var(--tx, 0px), var(--ty, 0px)) translate(-1px, 1px) rotate(-0.5deg); }
            50% { transform: translate(var(--tx, 0px), var(--ty, 0px)) translate(1px, -1px) rotate(0.5deg); }
            75% { transform: translate(var(--tx, 0px), var(--ty, 0px)) translate(-1px, -1px) rotate(-0.5deg); }
        }
        /* --- END: Logo Shake Effect --- */


        .spark-particle { position: absolute; width: 2px; height: 2px; border-radius: 50%; pointer-events: none; z-index: 10; opacity: 1; background-color: #fff; transition: transform 0.6s cubic-bezier(0.1, 0.7, 0.9, 1), opacity 0.6s ease-out; box-shadow: 0 0 3px #fff; }

        .tv-power-light {
            position: absolute;
            bottom: 2%;
            left: 53%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #330800;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
            opacity: 0;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            z-index: 5;
        }

        .tv-frame:hover .tv-power-light {
            opacity: 1;
            background-color: var(--tv-hover-light);
            box-shadow: 0 0 5px 2px var(--tv-hover-light),
                        0 0 8px 3px rgba(255, 80, 0, 0.5),
                        inset 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .tv-frame.can-upgrade-glow .tv-power-light {
            opacity: 1;
            background-color: var(--tv-upgrade-light);
            box-shadow: 0 0 6px 3px var(--tv-upgrade-light),
                        0 0 10px 4px rgba(0, 221, 255, 0.6),
                        inset 0 0 2px rgba(255, 255, 255, 0.4);
        }

        #upgrade-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 1000; }
        #upgrade-modal.show { display: flex; }
        .modal-content { background-color: var(--modal-bg-translucent); padding: 20px 25px; border-radius: 10px; border: 1px solid var(--modal-border); box-shadow: 0 5px 25px rgba(0,0,0,0.5); width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; position: relative; }
        .modal-header { font-size: clamp(1.2rem, 3vw, 1.6rem); font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); text-align: center; color: var(--accent-color); }
        .modal-header .tv-stats { font-size: 0.7em; font-weight: normal; color: #bbb; display: block; margin-top: 5px; }
        .modal-close-button { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; color: var(--disabled-color); background: none; border: none; cursor: pointer; padding: 0; line-height: 1; }
        .modal-close-button:hover { color: var(--text-color); }
        #modal-tv-options-container { text-align:center; margin-bottom: 10px; }
        #modal-buy-amount-container { display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; }
        .buy-amount-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: background-color 0.2s; }
        .buy-amount-button:hover { background-color: var(--button-hover); }
        .buy-amount-button.active { background-color: var(--button-active); border-color: #999; font-weight: bold; }
        .upgrades-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(125px, 1fr)); gap: 10px; width: 100%; margin-bottom: 15px;}
        .upgrade-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 10px 6px; border-radius: 6px; cursor: pointer; font-size: clamp(0.7rem, 2vw, 0.85rem); transition: background-color 0.2s, transform 0.1s; text-align: center; min-height: 85px; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        .upgrade-button:hover:not(:disabled) { background-color: var(--button-hover); }
        .upgrade-button:active:not(:disabled) { transform: scale(0.96); }
        .upgrade-button:disabled { background-color: #333; color: var(--disabled-color); cursor: not-allowed; opacity: 0.6; }
        .upgrade-description { flex-grow: 1; margin-bottom: 4px; }
        .upgrade-description strong { font-size: 1.1em; display: block; margin-bottom: 3px; line-height: 1.1; }
        .upgrade-cost { font-size: 0.9em; font-weight: bold; margin-top: auto; }
        .upgrade-cost.hit { color: var(--highlight-color-hits); }
        .upgrade-cost.meta { color: var(--meta-color); }
        .upgrade-button:disabled .upgrade-cost { color: var(--disabled-color); opacity: 0.8; }
        #modal-reboot-section-container { width: 100%; }
        #reboot-section { border-top: 1px dashed var(--meta-color); margin-top: 15px; padding-top: 15px; text-align: center; }

        #reboot-gain-preview { margin-bottom: 12px; font-weight: bold; font-size: 0.9em; }

        /* --- START: Progress Bar Styles --- */
        #reboot-progress-container {
            width: 85%;
            max-width: 300px;
            margin: 10px auto 15px auto; /* Centered, with margin */
            background-color: #383838;
            border-radius: 6px;
            height: 22px;
            position: relative;
            overflow: hidden; /* Clip the inner bar */
            border: 1px solid #555;
        }
        #reboot-progress-bar {
            height: 100%;
            width: 0%; /* Updated by JS */
            background-color: var(--meta-color); /* Use meta color */
            border-radius: 5px; /* Match container, slightly smaller if needed */
            transition: width 0.3s ease-out;
            position: relative; /* For text positioning context */
        }
        #reboot-progress-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.6);
            white-space: nowrap; /* Prevent wrapping */
            z-index: 1; /* Ensure text is above the bar fill */
            padding: 0 5px; /* Prevent text touching edges */
            box-sizing: border-box;
        }
        /* --- END: Progress Bar Styles --- */

        #reboot-button { background-color: var(--meta-color); color: #fff; border: 1px solid #505; padding: 8px 18px; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: bold; transition: background-color 0.2s, transform 0.1s; }
        #reboot-button:hover:not(:disabled) { background-color: #ff40ff; }
        #reboot-button:active:not(:disabled) { transform: scale(0.96); }
        #reboot-button:disabled { background-color: #606; color: var(--disabled-color); cursor: not-allowed; }

        /* --- Action Buttons --- */
        .action-button-container { /* Common container style */
            position: fixed;
            display: flex;
            gap: 10px;
            z-index: 900;
        }
        #meta-button-container { /* Bottom Left */
            bottom: 15px;
            left: 15px;
        }
        #screen-burn-container { /* Bottom Right */
             bottom: 15px;
             right: 15px;
         }
         /* New: Corner Bet Button Container */
        #corner-bet-container { /* Bottom Center */
             bottom: 15px;
             left: 50%;
             transform: translateX(-50%);
             /* No position: fixed needed as action-button-container handles it */
         }

        .action-button {
            background-color: var(--button-bg);
            color: white;
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 1.5rem; /* Adjust as needed */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            transition: background-color 0.2s, transform 0.2s, opacity 0.3s;
            position: relative; /* For potential cooldown overlays */
            overflow: hidden; /* Hide text overflow */
        }
        .action-button:hover:not(:disabled) { transform: scale(1.1); }
        .action-button:active:not(:disabled) { transform: scale(1.0); }
        .action-button:disabled { background-color: #333; color: var(--disabled-color); cursor: not-allowed; opacity: 0.6; }
        .action-button .button-text { font-size: 0.6rem; position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%); white-space: nowrap; background: rgba(0,0,0,0.7); padding: 1px 4px; border-radius: 3px; display: none; } /* Hide text by default */
        .action-button:hover .button-text { display: block; } /* Show on hover */
        .action-button .cooldown-text {
            font-size: 0.6rem; /* Adjust size as needed */
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
            pointer-events: none; /* Allow clicks to pass through */
            white-space: nowrap;
            line-height: 1;
            display: none; /* Hide by default */
        }


        #meta-menu-button {
            background-color: var(--meta-color);
            border-color: #505;
            display: none; /* Initially hidden, shown by JS */
        }
        #meta-menu-button:hover:not(:disabled) { background-color: #ff40ff; }
        #meta-menu-button.show { display: flex; }

        #screen-burn-button {
            background-color: var(--screen-burn-color);
            border-color: #8b2500; /* Darker orange/red */
            display: none; /* Initially hidden */
        }
         #screen-burn-button:hover:not(:disabled) { background-color: #ff6347; } /* Lighter Tomato */
         #screen-burn-button:disabled .cooldown-text { display: block; } /* Show cooldown text when disabled */
         #screen-burn-button:not(:disabled) .cooldown-text { display: none; } /* Hide cooldown text when ready */

         /* New: Corner Bet Button */
         #corner-bet-button {
             background-color: var(--corner-bet-color);
             border-color: #b8860b; /* DarkGoldenrod */
             color: #111; /* Dark text for contrast */
             font-weight: bold;
             display: none; /* Initially hidden, shown by JS */
         }
         #corner-bet-button:hover:not(:disabled) { background-color: #ffec8b; /* LightGoldenrod */ }
         #corner-bet-button:disabled {
             background-color: #665a2b; /* Darker Gold */
             opacity: 0.7;
             cursor: not-allowed;
         }
         #corner-bet-button.bet-active {
             background-color: #999 !important; /* Grey out when bet is active */
             border-color: #666 !important;
             cursor: not-allowed;
         }
         #corner-bet-button.bet-active::after {
            content: '⏳'; /* Indicate waiting */
            position: absolute;
            font-size: 1.2rem;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.8;
            pointer-events: none;
         }

        /* --- End Action Buttons --- */

        #notification { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: rgba(30, 30, 30, 0.85); color: white; padding: 8px 15px; border-radius: 5px; font-size: 0.85rem; opacity: 0; transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out; pointer-events: none; z-index: 1100; text-align: center; border: 1px solid #555;}
        #notification.show { opacity: 1; top: 25px; }

        .float-text { position: absolute; font-family: 'Courier New', Courier, monospace; font-weight: bold; z-index: 100; pointer-events: none; opacity: 0; white-space: pre; text-align: center; will-change: transform, opacity; }
        .corner-hit-text { top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--highlight-color-corners); font-size: clamp(1.5rem, 4vw, 2.4rem); text-shadow: 1px 1px #111, 0 0 15px var(--highlight-color-corners), 0 0 5px white; animation: cornerHitAnim 1.3s ease-out forwards; z-index: 101; }
        .collision-text { color: var(--collision-color); font-size: clamp(0.9rem, 2.5vw, 1.4rem); text-shadow: 1px 1px #111, 0 0 8px var(--collision-color); animation: floatFadeUp 0.9s ease-out forwards; z-index: 99; }
        .wall-hit-text { color: var(--highlight-color-wall); font-size: clamp(0.8rem, 2.2vw, 1.2rem); text-shadow: 1px 1px #111, 0 0 6px var(--highlight-color-wall); animation: floatFadeUp 0.8s ease-out forwards; z-index: 98; }
        .burn-hit-text { color: var(--screen-burn-color); font-size: clamp(0.7rem, 2vw, 1.1rem); text-shadow: 1px 1px #111, 0 0 6px var(--screen-burn-color); animation: floatFadeUpShort 0.6s ease-out forwards; z-index: 97; }


        @keyframes floatFadeUp { 0% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); } }
        @keyframes floatFadeUpShort { 0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); } }
        @keyframes cornerHitAnim { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(0.95); } 100% { opacity: 0; transform: translate(-50%, -180%) scale(0.7); } }

        svg { position:absolute; height: 0; width: 0; }

         /* Dev Panel Specific Styles */
         #dev-panel-container { /* Container for Dev Tools */
             position: fixed;
             top: 15px; /* Moved to top */
             left: 15px; /* Moved to left */
             z-index: 950;
             display: flex;
             flex-direction: column;
             align-items: flex-start; /* Align items to the left */
         }

        #dev-button {
            padding: 8px 12px;
            background-color: #500;
            color: white;
            border: 1px solid #a00;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.9rem;
            margin-bottom: 5px; /* Space between button and panel */
        }
        #dev-panel {
            background-color: rgba(40, 0, 0, 0.85);
            border: 1px solid #a00;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* Removed fixed positioning, handled by container */
        }
        #dev-panel label {
            color: #ccc;
            font-size: 0.8rem;
            display: block;
            margin-bottom: 2px;
        }
        #dev-panel input[type="number"] {
            width: 60px;
            padding: 3px;
            background-color: #222;
            border: 1px solid #555;
            color: #eee;
            font-size: 0.9rem;
            border-radius: 3px;
             margin-right: 5px;
        }
        #dev-panel button {
             background-color: #333;
             color: #eee;
             border: 1px solid #666;
             padding: 5px;
             cursor: pointer;
             font-size: 0.8rem;
         }
        #dev-hard-reset {
            background-color: #800 !important; /* Ensure override */
            color: white !important;
            border: 1px solid #f00 !important;
            margin-top: 5px;
        }

        /* --- Bet Result Overlay Styles --- */
        #bet-result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
            color: white;
            font-size: clamp(4rem, 15vw, 8rem); /* Huge text */
            font-weight: bold;
            text-align: center;
            z-index: 1200; /* Above everything else */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease-in-out;
            text-shadow: 3px 3px 0px rgba(0,0,0,0.5);
            line-height: 1.1;
            white-space: pre-wrap; /* Allow line breaks */
        }
        #bet-result-overlay.show {
            opacity: 1;
            pointer-events: auto; /* Block clicks while shown */
        }
        #bet-result-overlay.win {
            color: var(--win-color);
            text-shadow: 3px 3px 0px #151, 0 0 25px var(--win-color);
        }
        #bet-result-overlay.loss {
            color: var(--loss-color);
            text-shadow: 3px 3px 0px #511, 0 0 25px var(--loss-color);
            font-size: clamp(3rem, 12vw, 6rem); /* Slightly smaller for loss */
        }
        #bet-result-overlay .bet-amount {
            font-size: 0.35em; /* Smaller font for the amount */
            margin-top: 5px;
            display: block; /* Ensure it's on its own line */
        }
        /* --- End Bet Result Overlay Styles --- */
    </style>
</head>
<body>

<!-- Loading Screen HTML -->
<div id="loading-screen">
    <div class="loading-logo-container">
         <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png" alt="">
    </div>
    <p class="loading-text">IDLE</p>
</div>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <filter id="crt-effect">
      <feGaussianBlur stdDeviation="0.2" result="blurred"/>
      <feComponentTransfer in="blurred" result="contrastBoost">
         <feFuncR type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncG type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncB type="linear" slope="1.03" intercept="-0.005"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<div id="game-container">
    <div id="top-info-bar">
        <div id="total-hits-display" class="top-info-display">Hits: 0</div>
    </div>
    <div id="tvs-display-area"></div>

    <!-- Meta Button Container (Bottom Left) -->
    <div id="meta-button-container" class="action-button-container">
        <button id="meta-menu-button" class="action-button" aria-label="Meta Upgrades & Reboot">✵</button>
    </div>

    <!-- Screen Burn Button Container (Bottom Right) -->
    <div id="screen-burn-container" class="action-button-container">
         <button id="screen-burn-button" class="action-button" aria-label="Activate Screen Burn" disabled>
             🔥
             <span class="cooldown-text"></span> <!-- Span for cooldown text overlay -->
         </button>
     </div>

    <!-- Corner Bet Button Container (Bottom Center) -->
    <div id="corner-bet-container" class="action-button-container">
         <button id="corner-bet-button" class="action-button" aria-label="Bet All Hits on Next Corner">?</button>
    </div>

    <!-- Bet Result Overlay -->
    <div id="bet-result-overlay"></div>

</div>

<div id="upgrade-modal">
    <div class="modal-content">
        <button class="modal-close-button" aria-label="Close Modal">×</button>
        <div class="modal-header">
            <span id="modal-title">Upgrades</span>
            <span id="modal-tv-stats" class="tv-stats"></span>
        </div>
        <div id="modal-tv-options-container"></div>
        <div id="modal-buy-amount-container"></div>
        <div id="modal-upgrades-section" class="upgrades-section"></div>
        <div id="modal-reboot-section-container"></div>
    </div>
</div>

<div id="reboot-section-template" style="display: none;">
    <div id="reboot-section">

        <div id="reboot-gain-preview">Gain ~0 Static Charges</div>
        <!-- START: Progress Bar HTML Structure -->
        <div id="reboot-progress-container">
          <span id="reboot-progress-text">Calculating...</span>
            <div id="reboot-progress-bar">
            </div>
        </div>
        <!-- END: Progress Bar HTML Structure -->
        <button id="reboot-button" disabled>Reboot System</button>
    </div>
</div>


<div id="notification"></div>

<!-- DEV Tools Container (Top Left) -->
<div id="dev-panel-container" class="hidden" >
    <button id="dev-button">DEV</button>
    <div id="dev-panel" class="hidden">
        <button id="dev-simulate-corner">Simulate Corner Hit</button>
        <div>
            <label for="dev-speed-input">Score Factor:</label>
            <input type="number" id="dev-speed-input" name="dev-speed-input" min="0.1" step="0.1" value="1.0">
        </div>
        <button id="dev-reset-burn-cd">Reset Burn CD</button>
        <button id="dev-hard-reset">Hard Reset Game</button>
    </div>
</div>
<!-- End DEV Tools Container -->

<script>
    (function() {

        // --- Game Constants & Variables ---
        let devSpeedFactor = 1;
        const DVD_LOGO_URL = 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png';
        const TV_BACKGROUND_URL = 'https://00s.myretrotvs.com/img/tvbackclean.webp';
        const BASE_LOGO_HEIGHT_SCREEN_RATIO = 0.14;
        const BASE_BOX_ASPECT_RATIO = 1.6;
        const BASE_SPEED_CONSTANT = 1.0;
        const MAX_BOXES_PER_TV = 15;
        const SAVE_VERSION = 'v0.13'; // Incremented version for Meta Balance Fixes
        const SAVE_KEY = `dvdVideoIdleSave_${SAVE_VERSION}`;
        const TICK_RATE_MS = 16;
        const COLLISION_ENERGY_LOSS = 0.96;
        const BOX_COLLISION_COOLDOWN_MS = 100;
        const BOX_COLLISION_SEPARATION_BUFFER = 0.1;
        const TV_COST_SCALING_FACTOR = 1.8;
        const MAX_BULK_BUY_CHECK = 10000;
        const IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR = 0.6;
        const MIN_LOADING_TIME_MS = 1500;
        const MIN_OFFLINE_TIME_MS = 60 * 1000;
        const MAX_OFFLINE_TIME_MS = 14 * 24 * 60 * 60 * 1000;
        const CORNERS_SUCK_TIME_SCALE_FACTOR = 3000;
        const CORNERS_SUCK_LEVEL_SCALE_FACTOR = 0.12; // FIX: Increased from 0.08
        const CORNERS_SUCK_MAX_MULTIPLIER = 3.0;
        const REBOOT_MIN_HITS_FOR_FIRST_CHARGE = 5000;
        const FIND_THRESHOLD_MAX_ITERATIONS = 1000;
        const FIND_THRESHOLD_MAX_HITS = 1e24;
        const SCREEN_BURN_DURATION_MS = 5000;
        const SCREEN_BURN_COOLDOWN_SECONDS = 60;
        const SCREEN_BURN_EFFECTIVE_HPS_FACTOR = 1.5;
        const LOGO_SHAKE_ANIMATION_DURATION = 300;
        const BET_RESULT_DISPLAY_MS = 3500;
        const CORNER_BET_TIMEOUT_MS = 2000;

        // --- DOM Element Selection ---
        const loadingScreen = document.getElementById('loading-screen');
        const totalHitsDisplay = document.getElementById('total-hits-display');
        const tvsDisplayArea = document.getElementById('tvs-display-area');
        const notificationElement = document.getElementById('notification');
        const upgradeModal = document.getElementById('upgrade-modal');
        const modalContent = upgradeModal.querySelector('.modal-content');
        const modalCloseButton = upgradeModal.querySelector('.modal-close-button');
        const modalTitle = upgradeModal.querySelector('#modal-title');
        const modalTvStats = upgradeModal.querySelector('#modal-tv-stats');
        const modalTvOptionsContainer = upgradeModal.querySelector('#modal-tv-options-container');
        const modalBuyAmountContainer = upgradeModal.querySelector('#modal-buy-amount-container');
        const modalUpgradesContainer = upgradeModal.querySelector('#modal-upgrades-section');
        const modalRebootContainer = upgradeModal.querySelector('#modal-reboot-section-container');
        const metaMenuButton = document.getElementById('meta-menu-button');
        const screenBurnButton = document.getElementById('screen-burn-button');
        const screenBurnCooldownText = screenBurnButton.querySelector('.cooldown-text');
        const cornerBetButton = document.getElementById('corner-bet-button');
        const betResultOverlay = document.getElementById('bet-result-overlay');


        // --- Game State ---
        let globalState;
        let selectedTvIndex = -1;
        let gameLoopInterval = null;
        let lastTimestamp = 0;
        let lastSaveTime = 0;
        let nextTvId = 0;
        let boxCollisionTimers = {};
        let selectedBuyAmount = 1;
        let timeHidden = null;
        let hitsThresholdCache = {};
        let betResultTimeout = null;

        // --- Utility Functions ---
        const calculateCost = (baseCost, level, factor = 1.5, tvIndex = -1) => { let cost = baseCost * Math.pow(factor, level); if (tvIndex >= 0 && tvIndex > 0) { cost *= Math.pow(TV_COST_SCALING_FACTOR, tvIndex); } return Math.max(1, Math.floor(cost)); };
        const formatScore = (value) => { const V = Math.floor(value); if (V < 1e4) return V.toLocaleString(); if (V < 1e6) return (V / 1e3).toFixed(V < 100e3 ? 1 : 0) + 'K'; if (V < 1e9) return (V / 1e6).toFixed(V < 100e6 ? 1 : 0) + 'M'; if (V < 1e12) return (V / 1e9).toFixed(V < 100e9 ? 1 : 0) + 'B'; if (V < 1e15) return (V / 1e12).toFixed(V < 100e12 ? 1 : 0) + 'T'; if (V < 1e18) return (V / 1e15).toFixed(V < 100e15 ? 1 : 0) + 'Qd'; return (V / 1e18).toFixed(1) + 'Qn'; };
        function getRandomColor() { let r, g, b; let color = '#'; const letters = '0123456789ABCDEF'; do { color = '#'; for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; } r = parseInt(color.substring(1, 3), 16); g = parseInt(color.substring(3, 5), 16); b = parseInt(color.substring(5, 7), 16); } while (r + g + b < 450 || (r > 200 && g > 200 && b > 200)); return color; }
        function getBoxCollisionKey(id1, id2) { return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`; }
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }

        // --- Image Preloading ---
        function preloadImages(urls) {
            const promises = urls.map(url => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = (err) => {
                        console.error(`Failed to load image: ${url}`, err);
                        resolve();
                    };
                    img.src = url;
                });
            });
            return Promise.all(promises);
        }

        // --- TV & Box Creation / Management ---
        function createTvDom(tvState) {
            const container = document.createElement('div');
            container.classList.add('tv-instance-container');
            container.dataset.tvIndex = tvState.index;

            const tvFrame = document.createElement('div');
            tvFrame.classList.add('tv-frame');
            tvFrame.id = `tv-frame-${tvState.id + 1}`;
            tvFrame.onclick = (e) => { e.stopPropagation(); openUpgradeModal(tvState.index); };

            const tvScreen = document.createElement('div');
            tvScreen.classList.add('tv-screen');
            tvScreen.id = `tv-screen-${tvState.id + 1}`;
            tvFrame.appendChild(tvScreen);

            const powerLight = document.createElement('div');
            powerLight.classList.add('tv-power-light');
            tvFrame.appendChild(powerLight);

            container.appendChild(tvFrame);
            tvsDisplayArea.appendChild(container);

            tvState.elements = { container, frame: tvFrame, screen: tvScreen, powerLight: powerLight };
            resizeTvScreen(tvState);
            updateTvGlow(tvState.index);
        }

        function createBoxElement(tvState, boxData) {
            if (!tvState.elements || !tvState.elements.screen) {
                console.error("TV screen element not found for TV", tvState.id + 1);
                return null;
            }
            if (!tvState.screenWidth || !tvState.screenHeight) {
                 console.warn("Screen dimensions not ready for TV", tvState.id + 1, "retrying box creation soon.");
                 if(!boxData.element){
                     setTimeout(() => {
                        if(globalState && globalState.tvStates[tvState.index]) {
                            const currentTvState = globalState.tvStates[tvState.index];
                            const reBox = currentTvState.boxes.find(b => b.id === boxData.id && !b.element);
                            if (reBox) {
                                reBox.element = createBoxElement(currentTvState, reBox);
                                if(reBox.element) {
                                    reBox.element.style.setProperty('--tx', `${reBox.x}px`);
                                    reBox.element.style.setProperty('--ty', `${reBox.y}px`);
                                    reBox.element.style.transform = `translate(var(--tx), var(--ty))`;
                                }
                            }
                        }
                     }, 100);
                 }
                 return null;
             }

            const boxElement = document.createElement('div');
            boxElement.classList.add('box');
            boxElement.id = `tv${tvState.id + 1}-box${boxData.id}`;
            boxElement.style.width = `${tvState.dynamicBoxWidth}px`;
            boxElement.style.height = `${tvState.dynamicBoxHeight}px`;
            boxElement.style.setProperty('--tx', `${boxData.x}px`);
            boxElement.style.setProperty('--ty', `${boxData.y}px`);
            boxElement.style.transform = `translate(var(--tx), var(--ty))`;
            boxElement.style.backgroundColor = getRandomColor();
            boxElement.style.maskImage = `url('${DVD_LOGO_URL}')`;
            boxElement.style.webkitMaskImage = `url('${DVD_LOGO_URL}')`;
            tvState.elements.screen.appendChild(boxElement);
            return boxElement;
        }

        function addBoxToTv(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            const currentMaxBoxes = globalState.maxBoxesPerTv;
            if (!tvState || tvState.boxes.length >= currentMaxBoxes) return false;

            if (!tvState.elements || !tvState.elements.screen || !tvState.screenWidth || !tvState.screenHeight) {
                 console.warn(`TV #${tvState.id + 1}: Screen dimensions not ready, delaying box add.`);
                 resizeTvScreen(tvState);
                 setTimeout(() => addBoxToTv(tvIndex), 100);
                 return false;
             }

            const id = tvState.nextBoxId++;
            const speed = getCurrentTvSpeed(tvState);
            const baseAngle = Math.PI / 4;
            const randomOffset = (Math.random() - 0.5) * (Math.PI / 6);
            const randomQuadrant = Math.floor(Math.random() * 4);
            const angle = baseAngle + randomOffset + randomQuadrant * (Math.PI / 2);

            let startX, startY, attempts = 0, tooClose;
            do {
                startX = Math.random() * (tvState.screenWidth - tvState.dynamicBoxWidth);
                startY = Math.random() * (tvState.screenHeight - tvState.dynamicBoxHeight);
                tooClose = tvState.boxes.some(eB => {
                    const dx=startX-eB.x; const dy=startY-eB.y;
                    return (dx*dx+dy*dy) < Math.pow(tvState.dynamicBoxWidth*1.5, 2);
                });
                attempts++;
            } while (tooClose && attempts < 10);

            const newBox = {
                id: id, x: startX, y: startY,
                vx: Math.cos(angle) * speed * 0.7, vy: Math.sin(angle) * speed * 0.7,
                element: null, burnEndTime: null
            };

            newBox.element = createBoxElement(tvState, newBox);

            if (newBox.element || !tvState.screenWidth) {
                 tvState.boxes.push(newBox);
                 updateTvGlow(tvIndex);
                 return true;
            } else {
                 console.warn("Box element creation potentially delayed for TV", tvState.id + 1);
                 tvState.boxes.push(newBox);
                 updateTvGlow(tvIndex);
                 return true;
            }
        }

        function addTv() {
            const newIndex = globalState.tvStates.length;
            const newId = nextTvId++;
            globalState.nextTvId = nextTvId;
            const newTvState = createDefaultTvState(newIndex, newId);
            applyMetaUpgradesToTv(newTvState);
            globalState.tvStates.push(newTvState);
            createTvDom(newTvState);
            addBoxToTv(newIndex);
            recalculateGlobalSynergy();
            updateMetaUpgradeButtonsIfVisible();
            updateAllTvGlows();
            showNotification(`TV #${newId + 1} Online`);
            return newTvState;
        }
        function removeAllDomElements() { tvsDisplayArea.innerHTML = ''; globalState.tvStates.forEach(tv => tv.elements = null); }
        function recreateAllDomElements() {
             removeAllDomElements();
             globalState.tvStates.forEach(tvState => {
                createTvDom(tvState);
                tvState.boxes.forEach(box => {
                    if (typeof box.x !== 'number' || typeof box.y !== 'number' || typeof box.vx !== 'number' || typeof box.vy !== 'number' || isNaN(box.x) || isNaN(box.y) || isNaN(box.vx) || isNaN(box.vy)) {
                        console.warn(`Invalid box data on load for TV ${tvState.id + 1} box ${box.id}. Resetting.`);
                        box.x = 50; box.y = 50; box.vx = (Math.random()-0.5)*0.5; box.vy = (Math.random()-0.5)*0.5;
                    }
                    box.burnEndTime = null;
                    box.element = null;
                    box.element = createBoxElement(tvState, box);
                     if (box.element) {
                         box.element.classList.remove('screen-burn-effect');
                         box.element.classList.remove('logo-shake');
                     }
                    if (!box.element && tvState.screenWidth) {
                        console.warn(`Box element recreation potentially delayed for TV ${tvState.id + 1} box ${box.id}`);
                    }
                 });
                 resizeTvScreen(tvState);
                 checkAndAdjustBoxPositions(tvState.index);
                 updateTvGlow(tvState.index);
             });
             updateAllTvGlows();
        }
         function clearTvScreenBoxes(tvIndex) {
             const tvState = globalState.tvStates[tvIndex];
             if (tvState && tvState.elements && tvState.elements.screen) {
                 tvState.elements.screen.innerHTML = '';
                 tvState.boxes.forEach(box => box.element = null);
             }
         }

        // --- Sizing and Positioning ---
        function resizeTvScreen(tvState) {
            if (!tvState.elements || !tvState.elements.screen) {
                 if (globalState && globalState.tvStates[tvState.index] && !tvState.elements) {
                     console.warn(`Elements missing for TV ${tvState.id + 1}, attempting recreation.`);
                     recreateAllDomElements();
                 }
                 return;
            }
            const screenRect = tvState.elements.screen.getBoundingClientRect();
            if (screenRect.width <= 0 || screenRect.height <= 0) {
                if (!document.hidden) {
                    if (!tvState.resizeRetryTimeout) {
                         tvState.resizeRetryTimeout = setTimeout(() => {
                             tvState.resizeRetryTimeout = null;
                             resizeTvScreen(tvState);
                         }, 150);
                     }
                }
                return;
            }

            const oldWidth = tvState.screenWidth;
            const oldHeight = tvState.screenHeight;
            tvState.screenWidth = screenRect.width;
            tvState.screenHeight = screenRect.height;
            tvState.dynamicBoxHeight = Math.max(8, Math.floor(tvState.screenHeight * BASE_LOGO_HEIGHT_SCREEN_RATIO));
            tvState.dynamicBoxWidth = Math.floor(tvState.dynamicBoxHeight * BASE_BOX_ASPECT_RATIO);

            if (Math.abs(tvState.screenWidth - oldWidth) > 1 || Math.abs(tvState.screenHeight - oldHeight) > 1) {
                 const now = Date.now();
                tvState.boxes.forEach(box => {
                    if (box.element) {
                        box.element.style.width = `${tvState.dynamicBoxWidth}px`;
                        box.element.style.height = `${tvState.dynamicBoxHeight}px`;
                    }
                    if (box.burnEndTime === null || now >= box.burnEndTime) {
                        box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                        box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                    }
                     if (box.element) {
                         box.element.style.setProperty('--tx', `${box.x}px`);
                         box.element.style.setProperty('--ty', `${box.y}px`);
                         box.element.style.transform = `translate(var(--tx), var(--ty))`;
                     }
                });
            }
        }

        function handleGlobalResize() {
            globalState.tvStates.forEach(tvState => {
                resizeTvScreen(tvState);
            });
        }
        function checkAndAdjustBoxPositions(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
             if (!tvState || !tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || tvState.screenWidth <= 0 || tvState.screenHeight <= 0) {
                 if (!document.hidden && !tvState.adjustRetryTimeout) {
                     tvState.adjustRetryTimeout = setTimeout(() => {
                         tvState.adjustRetryTimeout = null;
                         checkAndAdjustBoxPositions(tvIndex);
                     }, 150);
                 }
                 return;
             }
            const now = Date.now();
            tvState.boxes.forEach(box => {
                 if (box.burnEndTime === null || now >= box.burnEndTime) {
                    box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                    box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                 }
                if (!box.element) {
                    box.element = createBoxElement(tvState, box);
                }
                 if (box.element) {
                    box.element.style.setProperty('--tx', `${box.x}px`);
                    box.element.style.setProperty('--ty', `${box.y}px`);
                    box.element.style.transform = `translate(var(--tx), var(--ty))`;
                 }
                if ((box.burnEndTime === null || now >= box.burnEndTime) && box.element) {
                    box.element.classList.remove('screen-burn-effect');
                    box.element.classList.remove('logo-shake');
                }
            });
        }

        // --- Update Loop ---
        function gameLoop(timestamp) {
            if (document.hidden) { return; }

            const now = Date.now();
            if (!lastTimestamp) { lastTimestamp = timestamp; return; }
            const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000);
            lastTimestamp = timestamp;

            globalState.tvStates.forEach((tvState, tvIndex) => {
                 if (!tvState.screenWidth || tvState.screenWidth <= 0) {
                    resizeTvScreen(tvState);
                 } else {
                    updateSingleTv(tvState, tvIndex, deltaTime, timestamp, now);
                 }
             });

            handleAutoBuying();

            updateTotalHitsDisplay();
            updateAllTvGlows();
            checkMetaButtonVisibility();
            updateScreenBurnButtonState(now);
            updateCornerBetButtonState();

            if (upgradeModal.classList.contains('show')) {
                hitsThresholdCache = {};
                if (selectedTvIndex !== -1) {
                    const tvState = globalState.tvStates[selectedTvIndex];
                    if (tvState) updateModalTvStats(tvState);
                    updateSelectedTvUpgradeButtons();
                } else {
                    modalTvStats.textContent = `Static Charges: ${formatScore(globalState.systemStaticCharges)}`;
                    updateMetaUpgradeButtonsIfVisible();
                    updateRebootPreviewIfVisible();
                }
            }

            const currentTimeForSave = Date.now();
            if (currentTimeForSave - lastSaveTime > 5000) {
                saveGame();
                lastSaveTime = currentTimeForSave;
            }
        }

        function handleAutoBuying() {
            if (!globalState || !globalState.tvStates) return;

            for (const tvState of globalState.tvStates) {
                if (tvState.index < globalState.metaLevels.autoBuyUnlockLevel && tvState.isAutoBuyActive) {
                    let affordableUpgrades = [];
                    for (const upgrade of tvUpgrades) {
                        const currentLevel = upgrade.getLevel(tvState);
                        let maxLevel;
                        if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
                        else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
                        else maxLevel = upgrade.maxLevel;

                        const isMaxLevel = (maxLevel !== undefined && currentLevel >= maxLevel);
                        if (isMaxLevel) continue;
                        let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true;
                        if (!canPurchaseCheck) continue;

                        const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvState.index);
                        if (globalState.totalSessionHits >= cost) {
                            affordableUpgrades.push({ upgrade, cost });
                        }
                    }

                    if (affordableUpgrades.length > 0) {
                        affordableUpgrades.sort((a, b) => a.cost - b.cost);
                        const { upgrade: upgradeToBuy, cost: costToBuy } = affordableUpgrades[0];
                        globalState.totalSessionHits -= costToBuy;
                        if (upgradeToBuy.id === 'multiBox') {
                            upgradeToBuy.applyEffect(tvState, tvState.index, 1);
                        } else {
                            upgradeToBuy.applyEffect(tvState, tvState.index);
                        }
                        recalculateDerivedTvState(tvState);
                    }
                }
            }
        }

        // --- updateSingleTv ---
        function updateSingleTv(tvState, tvIndex, deltaTime, timestamp, now) {
             if (!tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || !tvState.dynamicBoxHeight || tvState.screenWidth <= 0 || tvState.screenHeight <= 0) {
                 return;
             }
            const screenWidth = tvState.screenWidth;
            const screenHeight = tvState.screenHeight;
            const effectiveBoxWidth = tvState.dynamicBoxWidth;
            const effectiveBoxHeight = tvState.dynamicBoxHeight;
            const currentSpeed = getCurrentTvSpeed(tvState);
            let cornerHitData = [];
            let boxCollisionsThisFrame = [];
            let wallHitData = [];
            let burnHitData = [];
            let betResolvedThisFrame = false;

            // --- Corner Bet Timeout Check ---
            if (globalState.isCornerBetActive && !betResolvedThisFrame) {
                if (now > globalState.cornerBetActivationTimestamp + CORNER_BET_TIMEOUT_MS) {
                    resolveCornerBet(false); // LOST due to timeout
                    betResolvedThisFrame = true;
                }
            }

            // --- Box Update Loop ---
            for (const box of tvState.boxes) {
                 if (betResolvedThisFrame) break;

                 if (!box.element) {
                     box.element = createBoxElement(tvState, box);
                     if(!box.element) continue;
                 }
                 box.element.style.setProperty('--tx', `${box.x}px`);
                 box.element.style.setProperty('--ty', `${box.y}px`);

                 const isBurning = box.burnEndTime !== null && now < box.burnEndTime;

                 // --- Screen Burn Logic ---
                 if (isBurning) {
                     if (box.element) {
                         box.element.classList.add('screen-burn-effect');
                         if (!box.element.classList.contains('logo-shake')) {
                              box.element.classList.add('logo-shake');
                              setTimeout(() => {
                                  if (box.element) { box.element.classList.remove('logo-shake'); }
                              }, LOGO_SHAKE_ANIMATION_DURATION);
                         }
                     }
                     let baseBurnHitAmount = tvState.hitValue;
                     const cornersSuckLevel = globalState.metaLevels.cornersSuckBonus;
                     // Apply Corners Suck to Burn Hits
                     if (cornersSuckLevel > 0) {
                         if (!tvState.lastCornerHitTimestamp) { tvState.lastCornerHitTimestamp = now; }
                         const elapsedMs = now - tvState.lastCornerHitTimestamp;
                         const bonusRatio = Math.min(CORNERS_SUCK_MAX_MULTIPLIER - 1, (elapsedMs / CORNERS_SUCK_TIME_SCALE_FACTOR) * (cornersSuckLevel * CORNERS_SUCK_LEVEL_SCALE_FACTOR));
                         baseBurnHitAmount *= (1 + bonusRatio);
                     }
                     const singleBurnHitValue = Math.ceil(baseBurnHitAmount * globalState.synergyBonus * devSpeedFactor);
                     const effectiveHitsPerSecondDuringBurn = singleBurnHitValue * SCREEN_BURN_EFFECTIVE_HPS_FACTOR;
                     const totalBurnHitsValueThisFrame = Math.max(1, Math.floor(effectiveHitsPerSecondDuringBurn * deltaTime));
                     if (totalBurnHitsValueThisFrame > 0) {
                         addTvHitScore(totalBurnHitsValueThisFrame); // Burn hits don't affect bet
                         if (Math.random() < 0.1) {
                            const popupX = box.x + effectiveBoxWidth / 2;
                            const popupY = box.y - (effectiveBoxHeight * 0.1);
                            burnHitData.push({ x: popupX, y: popupY, amount: singleBurnHitValue });
                         }
                     }
                 } else {
                      // --- Not Burning ---
                     if (box.burnEndTime !== null && now >= box.burnEndTime) {
                         box.burnEndTime = null;
                         if (box.element) {
                             box.element.classList.remove('screen-burn-effect');
                             box.element.classList.remove('logo-shake');
                         }
                     }

                     // --- Normal Movement & Wall Collision ---
                     if (isNaN(box.vx) || isNaN(box.vy)) { box.vx = (Math.random()-0.5)*currentSpeed*0.5; box.vy = (Math.random()-0.5)*currentSpeed*0.5; };
                     let boxVX = box.vx; let boxVY = box.vy;
                     const speedMagnitude = Math.sqrt(boxVX**2 + boxVY**2);
                     if (speedMagnitude > 0.01 && Math.abs(speedMagnitude - currentSpeed) > 0.1 * currentSpeed) {
                         const sf = currentSpeed/speedMagnitude;
                         boxVX*=(isNaN(sf)?1:sf); boxVY*=(isNaN(sf)?1:sf);
                     } else if (speedMagnitude < 0.1*currentSpeed && currentSpeed > 0.1) {
                         const a = Math.random()*Math.PI*2;
                         boxVX=Math.cos(a)*currentSpeed*0.5; boxVY=Math.sin(a)*currentSpeed*0.5;
                     }

                     let deltaX = boxVX * deltaTime * 60; let deltaY = boxVY * deltaTime * 60;
                     deltaX = Math.max(-effectiveBoxWidth*0.8,Math.min(effectiveBoxWidth*0.8,deltaX));
                     deltaY = Math.max(-effectiveBoxHeight*0.8,Math.min(effectiveBoxHeight*0.8,deltaY));
                     box.x += deltaX; box.y += deltaY;

                     let hitWall=false; let hitX=false, hitY=false; let hitSide = '';
                     if (box.x <= 0 && boxVX < 0) { box.x = 0+Math.random()*0.1; boxVX = Math.abs(boxVX); hitWall=true; hitX=true; hitSide='left';}
                     else if (box.x >= screenWidth-effectiveBoxWidth && boxVX > 0) { box.x = screenWidth-effectiveBoxWidth-Math.random()*0.1; boxVX = -Math.abs(boxVX); hitWall=true; hitX=true; hitSide='right';}
                     if (box.y <= 0 && boxVY < 0) { box.y = 0+Math.random()*0.1; boxVY = Math.abs(boxVY); hitWall=true; hitY=true; hitSide='top';}
                     else if (box.y >= screenHeight-effectiveBoxHeight && boxVY > 0) { box.y = screenHeight-effectiveBoxHeight-Math.random()*0.1; boxVY = -Math.abs(boxVY); hitWall=true; hitY=true; hitSide='bottom';}

                     // --- Handle Wall Hit ---
                     if (hitWall) {
                         if (box.element) box.element.style.backgroundColor = getRandomColor();

                         const cornerThreshold = Math.min(1.5, effectiveBoxWidth * 0.03, effectiveBoxHeight * 0.03);
                         const isNearLeft = box.x <= cornerThreshold; const isNearRight = box.x >= screenWidth-effectiveBoxWidth-cornerThreshold;
                         const isNearTop = box.y <= cornerThreshold; const isNearBottom = box.y >= screenHeight-effectiveBoxHeight-cornerThreshold;
                         const isCorner = (isNearLeft || isNearRight) && (isNearTop || isNearBottom);

                         // --- Corner Hit Logic ---
                         if (isCorner && hitX && hitY) {
                            tvState.lastCornerHitTimestamp = now; // Reset timestamp
                            let cornerX = isNearLeft ? 0 : screenWidth;
                            let cornerY = isNearTop ? 0 : screenHeight;
                            const escapeFactor = 1.08;
                            if (isNearLeft) boxVX=Math.abs(boxVX)*escapeFactor; else boxVX=-Math.abs(boxVX)*escapeFactor;
                            if (isNearTop) boxVY=Math.abs(boxVY)*escapeFactor; else boxVY=-Math.abs(boxVY)*escapeFactor;

                            if (globalState.isCornerBetActive && !betResolvedThisFrame) {
                                resolveCornerBet(true); // WIN!
                                betResolvedThisFrame = true;
                            } else if (!globalState.isCornerBetActive) {
                                const finalCornerBonus = Math.ceil(tvState.cornerHitBaseBonus * tvState.cornerHitMultiplier * globalState.synergyBonus * devSpeedFactor);
                                addTvHitScore(finalCornerBonus);
                                cornerHitData.push({ x: cornerX, y: cornerY, boxId: box.id, bonusAmount: finalCornerBonus });
                            }
                         }
                         // --- Regular Wall Hit Logic ---
                         else {
                            // Non-corner wall hit does NOT resolve bet.
                            // Only score/effect if bet is NOT active.
                            if (!globalState.isCornerBetActive) {
                                 let baseWallHitAmount = tvState.hitValue;
                                 const cornersSuckLevel = globalState.metaLevels.cornersSuckBonus;
                                 // Apply Corners Suck to Wall Hits
                                 if (cornersSuckLevel > 0) {
                                     if (!tvState.lastCornerHitTimestamp) { tvState.lastCornerHitTimestamp = now; }
                                     const elapsedMs = now - tvState.lastCornerHitTimestamp;
                                     const bonusRatio = Math.min(CORNERS_SUCK_MAX_MULTIPLIER - 1, (elapsedMs / CORNERS_SUCK_TIME_SCALE_FACTOR) * (cornersSuckLevel * CORNERS_SUCK_LEVEL_SCALE_FACTOR));
                                     baseWallHitAmount *= (1 + bonusRatio);
                                 }
                                 const finalWallHitAmount = Math.ceil(baseWallHitAmount * globalState.synergyBonus * devSpeedFactor);
                                 addTvHitScore(finalWallHitAmount);

                                 let popupX = box.x + effectiveBoxWidth / 2; let popupY = box.y + effectiveBoxHeight / 2;
                                 if (hitSide === 'left') popupX = effectiveBoxWidth * 0.5; else if (hitSide === 'right') popupX = screenWidth - effectiveBoxWidth * 0.5;
                                 if (hitSide === 'top') popupY = effectiveBoxHeight * 0.5; else if (hitSide === 'bottom') popupY = screenHeight - effectiveBoxHeight * 0.5;
                                 wallHitData.push({ x: popupX, y: popupY, amount: finalWallHitAmount });
                             }
                         }
                     }
                     box.vx = boxVX; box.vy = boxVY;
                     box.x = Math.max(0, Math.min(box.x, screenWidth - effectiveBoxWidth));
                     box.y = Math.max(0, Math.min(box.y, screenHeight - effectiveBoxHeight));
                 } // End non-burning block
            } // End box loop

            // --- Box-on-box collision ---
            if (!betResolvedThisFrame) {
                for (let i = 0; i < tvState.boxes.length; i++) {
                    if (!tvState.boxes[i].element) continue;
                    for (let j = i + 1; j < tvState.boxes.length; j++) {
                       if (!tvState.boxes[j].element) continue;

                       const b1 = tvState.boxes[i]; const b2 = tvState.boxes[j];
                       const b1IsBurning = b1.burnEndTime !== null && now < b1.burnEndTime;
                       const b2IsBurning = b2.burnEndTime !== null && now < b2.burnEndTime;
                       if (b1IsBurning && b2IsBurning) continue;

                       const b1CenterX = b1.x + effectiveBoxWidth / 2; const b1CenterY = b1.y + effectiveBoxHeight / 2;
                       const b2CenterX = b2.x + effectiveBoxWidth / 2; const b2CenterY = b2.y + effectiveBoxHeight / 2;
                       const dx = b2CenterX - b1CenterX; const dy = b2CenterY - b1CenterY;
                       const overlapX = effectiveBoxWidth - Math.abs(dx); const overlapY = effectiveBoxHeight - Math.abs(dy);

                       if (overlapX > 0 && overlapY > 0) {
                           const collisionKey = getBoxCollisionKey(b1.id, b2.id);
                           const lastCollisionTime = boxCollisionTimers[collisionKey] || 0;
                           if (timestamp - lastCollisionTime < BOX_COLLISION_COOLDOWN_MS) continue;
                           boxCollisionTimers[collisionKey] = timestamp;

                           let collisionOccurred = false;
                           let collisionX = b1CenterX + dx / 2; let collisionY = b1CenterY + dy / 2;

                           // Collision does NOT resolve bet.
                           // Only process physics/scoring if bet is NOT active.
                           if (!globalState.isCornerBetActive) {
                               if (b1IsBurning || b2IsBurning) { // Collision with burning box
                                   const movingBox = b1IsBurning ? b2 : b1;
                                   const isB1Moving = !b1IsBurning;
                                   if (overlapX < overlapY) {
                                       const separationAmount = overlapX * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dx < 0 ? -1 : 1;
                                       movingBox.x += separationAmount * (isB1Moving ? -sign : sign) * 2;
                                       movingBox.vx = -movingBox.vx * COLLISION_ENERGY_LOSS;
                                   } else {
                                       const separationAmount = overlapY * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dy < 0 ? -1 : 1;
                                       movingBox.y += separationAmount * (isB1Moving ? -sign : sign) * 2;
                                       movingBox.vy = -movingBox.vy * COLLISION_ENERGY_LOSS;
                                   }
                                    movingBox.x = Math.max(0, Math.min(movingBox.x, screenWidth - effectiveBoxWidth));
                                    movingBox.y = Math.max(0, Math.min(movingBox.y, screenHeight - effectiveBoxHeight));
                                   collisionOccurred = true;
                               } else { // Normal collision
                                   if (overlapX < overlapY) {
                                       const separationAmount = overlapX * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dx < 0 ? -1 : 1;
                                       b1.x -= separationAmount * sign; b2.x += separationAmount * sign;
                                       const v1x = b1.vx; b1.vx = b2.vx * COLLISION_ENERGY_LOSS; b2.vx = v1x * COLLISION_ENERGY_LOSS;
                                   } else {
                                       const separationAmount = overlapY * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dy < 0 ? -1 : 1;
                                       b1.y -= separationAmount * sign; b2.y += separationAmount * sign;
                                       const v1y = b1.vy; b1.vy = b2.vy * COLLISION_ENERGY_LOSS; b2.vy = v1y * COLLISION_ENERGY_LOSS;
                                   }
                                   b1.x = Math.max(0, Math.min(b1.x, screenWidth - effectiveBoxWidth)); b1.y = Math.max(0, Math.min(b1.y, screenHeight - effectiveBoxHeight));
                                   b2.x = Math.max(0, Math.min(b2.x, screenWidth - effectiveBoxWidth)); b2.y = Math.max(0, Math.min(b2.y, screenHeight - effectiveBoxHeight));
                                   collisionOccurred = true;
                               }

                               if(collisionOccurred) {
                                    boxCollisionsThisFrame.push({ b1Id: b1.id, b2Id: b2.id, x: collisionX, y: collisionY });
                               }
                           }
                       }
                   }
                }
            }

            // --- Update Element Positions ---
            tvState.boxes.forEach(box => {
                if (box.element) {
                     box.element.style.setProperty('--tx', `${box.x}px`);
                     box.element.style.setProperty('--ty', `${box.y}px`);
                }
            });

            // --- Process Hit Effects (Only if bet NOT resolved AND NOT active) ---
            if (!betResolvedThisFrame && !globalState.isCornerBetActive) {
                if (wallHitData.length > 0) {
                     wallHitData.forEach(hit => {
                        showFloatText(tvState, `+${formatScore(hit.amount)}`, hit.x, hit.y, 'wall');
                     });
                }
                if (cornerHitData.length > 0) {
                    cornerHitData.forEach(hit => {
                        createSparkParticles(tvState, hit.x, hit.y);
                        showFloatText(tvState, `CORNER HIT!\n+${formatScore(hit.bonusAmount)}`, tvState.screenWidth/2, tvState.screenHeight/2, 'corner');
                    });
                }
                if (boxCollisionsThisFrame.length > 0) {
                    let collisionValue = tvState.boxCollisionValue;
                    let finalCollisionValue = Math.ceil(collisionValue * globalState.synergyBonus * devSpeedFactor);
                    let totalCollisionBonus = boxCollisionsThisFrame.length * finalCollisionValue;
                    addTvHitScore(totalCollisionBonus);
                    boxCollisionsThisFrame.forEach(hit => {
                        showFloatText(tvState, `+${formatScore(finalCollisionValue)}`, hit.x, hit.y, 'collision');
                    });
                }
            }
            // Show burn text regardless of bet state
            if (burnHitData.length > 0) {
                burnHitData.forEach(hit => {
                   showFloatText(tvState, `+${formatScore(hit.amount)}🔥`, hit.x, hit.y, 'burn');
                });
           }
        } // End updateSingleTv

        // --- Scoring & Stats ---
        function addTvHitScore(finalAmount) {
            if (finalAmount <= 0 || isNaN(finalAmount)) return;
            if (globalState.isCornerBetActive) { return; } // Bet handles scoring
            const effectiveGain = Math.ceil(finalAmount);
            if (effectiveGain <= 0) return;
            globalState.totalSessionHits += effectiveGain;
            globalState.lifetimeSessionHits += effectiveGain;
        }
        function updateModalTvStats(tvState) { if (!modalTvStats || !tvState) return; const currentMaxBoxes = globalState.maxBoxesPerTv; modalTvStats.textContent = `TV #${tvState.id + 1} | Logos: ${tvState.boxes.length}/${currentMaxBoxes}`; }
        function updateTotalHitsDisplay() { if (totalHitsDisplay) { totalHitsDisplay.textContent = `Hits: ${formatScore(globalState.totalSessionHits)}`; } }

        // --- Effects & Feedback ---
        function createSparkParticles(tvState, cornerX, cornerY) { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const particleCount = 12; const particleLifespan = 650; const particleSpread = tvState.screenWidth * 0.18; for (let i = 0; i < particleCount; i++) { const p = document.createElement('div'); p.classList.add('spark-particle'); p.style.left = `${cornerX}px`; p.style.top = `${cornerY}px`; screenElement.appendChild(p); const ang = Math.random()*Math.PI*2; const dist = Math.random()*particleSpread; let dX=Math.cos(ang); let dY=Math.sin(ang); if(cornerX<tvState.screenWidth/2) dX=Math.abs(dX); else dX=-Math.abs(dX); if(cornerY<tvState.screenHeight/2) dY=Math.abs(dY); else dY=-Math.abs(dY); const tX=dX*dist; const tY=dY*dist; requestAnimationFrame(()=>{p.style.transform=`translate(${tX}px, ${tY}px) scale(0.5)`; p.style.opacity=0; }); setTimeout(()=>{ p.remove(); }, particleLifespan); } }
        function showNotification(message) { if (!notificationElement) return; notificationElement.textContent = message; notificationElement.className = 'show'; if (notificationElement.timer) clearTimeout(notificationElement.timer); notificationElement.timer = setTimeout(() => { notificationElement.className = ''; notificationElement.timer = null; }, 2800); }
        function showFloatText(tvState, text, x, y, type = 'corner' | 'collision' | 'wall' | 'burn') {
             if (!tvState.elements || !tvState.elements.screen) return;
             if (globalState.isCornerBetActive && type !== 'burn') return; // Don't show non-burn during bet

             const screenElement = tvState.elements.screen;
             const textElement = document.createElement('div');
             textElement.classList.add('float-text');
             let textClass = ''; let duration = 1000;
             switch(type) {
                 case 'corner': textClass = 'corner-hit-text'; duration = 1300; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break;
                 case 'collision': textClass = 'collision-text'; duration = 900; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break;
                 case 'wall': textClass = 'wall-hit-text'; duration = 800; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break;
                 case 'burn': textClass = 'burn-hit-text'; duration = 600; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break;
                 default: console.warn("Unknown float text type:", type); return;
             }
             textElement.classList.add(textClass);
             textElement.innerHTML = text;
             screenElement.appendChild(textElement);
             setTimeout(() => { if (textElement.parentNode) textElement.remove(); }, duration);
        }
        function showBetResultOverlay(message, amount, isWin) {
            if (!betResultOverlay) return;
            if (betResultTimeout) clearTimeout(betResultTimeout);
            const sign = isWin ? '+' : '-';
            const amountText = `(${sign}${formatScore(amount)})`;
            betResultOverlay.innerHTML = `${message}<span class="bet-amount">${amountText}</span>`;
            betResultOverlay.className = 'show';
            betResultOverlay.classList.add(isWin ? 'win' : 'loss');
            betResultTimeout = setTimeout(() => {
                betResultOverlay.classList.remove('show');
                betResultTimeout = null;
            }, BET_RESULT_DISPLAY_MS);
        }

        // --- Glow Logic ---
        function checkTvAffordability(tvState) {
             if (!tvState) return false;
             const currentHits = globalState.totalSessionHits;
             for (const upgrade of tvUpgrades) {
                 const level = upgrade.getLevel(tvState);
                 let maxLevel;
                 if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
                 else maxLevel = upgrade.maxLevel;
                 const isMaxLevel = (maxLevel !== undefined && level >= maxLevel);
                 if (isMaxLevel) continue;
                 let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, level) : true;
                 if (!canPurchaseCheck) continue;
                 const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor, tvState.index);
                 if (currentHits >= cost) { return true; }
             }
             return false;
        }
        function updateTvGlow(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            if (tvState && tvState.elements && tvState.elements.frame) {
                const frame = tvState.elements.frame;
                const canAfford = checkTvAffordability(tvState);
                frame.classList.toggle('can-upgrade-glow', canAfford);
            }
        }
        function updateAllTvGlows() { globalState.tvStates.forEach((tv, index) => updateTvGlow(index)); }

        // --- Upgrade Definitions ---
        const tvUpgrades = [
             { id: 'hitValue', name: 'Hit Value', baseCost: 10, costFactor: 1.45, getLevel: (tv) => tv.upgrades.hitValue, applyEffect: (tv) => { tv.upgrades.hitValue++; },
               getDescription: (tv, l) => `<strong>More Hits Per Hit</strong><br>Lv ${l}: +Base Hit Value` },
             { id: 'speed', name: 'Speed', baseCost: 40, costFactor: 1.65, maxLevel: 25, getLevel: (tv) => tv.upgrades.speed, applyEffect: (tv) => { tv.upgrades.speed++; },
               getDescription: (tv, l, maxed) => `<strong>Gotta Go Fast</strong><br>${maxed ? `Max Speed (Lv ${l})` : `Lv ${l}: +Logo Speed`}` },
             { id: 'cornerBonusFlat', name: 'Corner Flat Bonus', baseCost: 250, costFactor: 1.75, getLevel: (tv) => tv.upgrades.cornerBonusFlat, applyEffect: (tv) => { tv.upgrades.cornerBonusFlat++; },
               getDescription: (tv, l) => `<strong>Big Corner Bonus</strong><br>Lv ${l}: +${formatScore(deriveTvCornerFlatBonus(tv,l+1) - tv.cornerHitBaseBonus)} Base Hits` },
             { id: 'cornerMultiplier', name: 'Corner Multiplier', baseCost: 2000, costFactor: 2.3, getLevel: (tv) => tv.upgrades.cornerMultiplier, applyEffect: (tv) => { tv.upgrades.cornerMultiplier++; },
               getDescription: (tv, l) => { const currentMult = deriveTvCornerMultiplier(tv, l); const nextMult = deriveTvCornerMultiplier(tv, l+1); return `<strong>Corner Multiplier</strong><br>Lv ${l}: x${currentMult.toFixed(2)} Corner Bonus<br>(Next: x${nextMult.toFixed(2)})`; } },
             { id: 'multiBox', name: 'Add Logo', baseCost: 300, costFactor: 3.5,
                getMaxLevel: (tv) => globalState.maxBoxesPerTv, getLevel: (tv) => tv.boxes.length,
                applyEffect: (tv, tvIndex, count = 1) => { let added = 0; for (let i = 0; i < count; i++) { if(addBoxToTv(tvIndex)) added++; else break; } if (added < count && count > 1 && tv.boxes.length >= globalState.maxBoxesPerTv) showNotification("Max logos reached!"); return added > 0; },
                canPurchase: (tv, levelToCheck) => (levelToCheck ?? tv.boxes.length) < globalState.maxBoxesPerTv,
                getDescription: (tv, l, maxed) => `<strong>More Logos!</strong><br>${maxed ? `Max Logos (${tv.boxes.length})` : `Add Logo (${l+1}/${globalState.maxBoxesPerTv})`}` },
             { id: 'boxCollisionValue', name: 'Collision Hits', baseCost: 1000, costFactor: 1.55, getLevel: (tv) => tv.upgrades.boxCollisionValue, applyEffect: (tv) => { tv.upgrades.boxCollisionValue++; },
               getDescription: (tv, l) => `<strong>Bumper Logos</strong><br>Lv ${l}: +Collision Hits between Logos` },
        ];
        const metaUpgrades = [
             { id: 'metaStaticChargeGain', name: 'Static Charge Gain', baseCost: 3, costFactor: 2.2, getLevel: () => globalState.metaLevels.staticChargeGain, applyEffect: () => { globalState.metaLevels.staticChargeGain++; },
               getDescription: (gs, l, c) => `<strong>Static Charge Boost</strong><br>Lv ${l}: +${((deriveMetaStaticChargeMult(l+1)-1)*100).toFixed(0)}% Static Charges<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaAddTv', name: 'Add New TV', baseCost: 1, costFactor: 4.5, getLevel: () => globalState.tvStates.length, applyEffect: () => { addTv(); }, canPurchase: () => true,
               getDescription: (gs, l, c) => `<strong>New Channel</strong><br>Unlock TV #${l + 1}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseSpeed', name: 'Base Speed', baseCost: 10, costFactor: 2.8, maxLevel: 15, getLevel: () => globalState.metaLevels.baseSpeed, applyEffect: () => { globalState.metaLevels.baseSpeed++; updateAllTvsPostMeta(); },
               getDescription: (gs, l, c, maxed) => `<strong>System Speed</strong><br>${maxed ? `Max Base Speed (Lv ${l})` : `Lv ${l}: +Base Speed All TVs`}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseMaxBoxes', name: 'Global Capacity', baseCost: 15, costFactor: 3.5, maxLevel: MAX_BOXES_PER_TV,
                getLevel: () => globalState.metaLevels.baseMaxBoxes, applyEffect: () => { globalState.metaLevels.baseMaxBoxes++; updateAllTvsPostMeta(); updateMetaUpgradeButtonsIfVisible(); updateSelectedTvUpgradeButtons(); },
                getDescription: (gs, l, c, maxed) => `<strong>More Room</strong><br>${maxed ? `Max Global Cap (${gs.maxBoxesPerTv})` : `Lv ${l}: +Global Max Logos (${deriveMetaBaseMaxBoxes(l+1)})`}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaTvSynergyBonus', name: 'TV Synergy', baseCost: 50, costFactor: 2.5, getLevel: () => globalState.metaLevels.tvSynergyBonus, applyEffect: () => { globalState.metaLevels.tvSynergyBonus++; recalculateGlobalSynergy(); updateMetaUpgradeButtonsIfVisible(); },
               getDescription: (gs, l, c) => { const nextLevel = l + 1; const nextPerTvBonus = deriveSynergyBonusPerTv(nextLevel); return `<strong>Teamwork!</strong><br>Lv ${l}: All Hits x${globalState.synergyBonus.toFixed(3)}<br>(+${(nextPerTvBonus*100).toFixed(2)}% per TV Next)<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`; } },
             { id: 'metaCornersSuck', name: 'Corners Suck', baseCost: 15, costFactor: 2.9,
               getLevel: () => globalState.metaLevels.cornersSuckBonus, applyEffect: () => { globalState.metaLevels.cornersSuckBonus++; },
               getDescription: (gs, l, c) => { const maxBonusPercent = (CORNERS_SUCK_MAX_MULTIPLIER - 1) * 100; return `<strong>Corners Suck</strong><br>Lv ${l}: +Wall hits value over time (Max +${maxBonusPercent.toFixed(0)}%)<br>Resets on TV corner hit<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`; }
             },
             { id: 'screenBurnAbility', name: 'Screen Burn', baseCost: 150, costFactor: 3.0,
               getLevel: () => globalState.metaLevels.screenBurnLevel,
               applyEffect: () => { globalState.metaLevels.screenBurnLevel++; updateScreenBurnButtonVisibility(); },
               getDescription: (gs, l, c) => {
                   let descriptionText = ''; const numLogosNext = l + 1;
                   if (l === 0) { descriptionText = `<strong>Unlock: Screen Burn 🔥</strong><br>Burn ${numLogosNext} logo for ${SCREEN_BURN_DURATION_MS/1000}s.<br>`; }
                   else { descriptionText = `<strong>Screen Burn 🔥</strong><br>Lv ${l}: Burn ${numLogosNext} logo${numLogosNext > 1 ? 's' : ''} for ${SCREEN_BURN_DURATION_MS/1000}s.<br>`; }
                   descriptionText += `Rapidly generates Hits. x${SCREEN_BURN_EFFECTIVE_HPS_FACTOR.toFixed(1)}/sec.<br>Cooldown: ${SCREEN_BURN_COOLDOWN_SECONDS/60} min.<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`;
                   return descriptionText;
               }
             },
             { id: 'cornerBetAbility', name: 'Corner Bet', baseCost: 50, costFactor: 3.2,
               getLevel: () => globalState.metaLevels.cornerBetLevel,
               applyEffect: () => { globalState.metaLevels.cornerBetLevel++; updateCornerBetButtonVisibility(); updateCornerBetButtonState(); },
               getDescription: (gs, l, c) => {
                   const currentMultiplier = deriveCornerBetMultiplier(l); const nextMultiplier = deriveCornerBetMultiplier(l + 1);
                   let descriptionText = '';
                   if (l === 0) { descriptionText = `<strong>Unlock: Corner Bet ?</strong><br>Bet ALL Hits on corner hit within ${CORNER_BET_TIMEOUT_MS/1000}s.<br>Win: x${nextMultiplier} Hits! Lose: All Hits.<br>`; }
                   else { descriptionText = `<strong>Corner Bet ?</strong><br>Lv ${l}: Win Multiplier x${currentMultiplier}<br>(Next: x${nextMultiplier})<br>Bet on corner hit within ${CORNER_BET_TIMEOUT_MS/1000}s.<br>`; }
                   descriptionText += `Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`;
                   return descriptionText;
               }
             },
             { id: 'autoBuyUnlock', name: 'TV Auto-Buyer', baseCost: 200, costFactor: 4.0,
                 getLevel: () => globalState.metaLevels.autoBuyUnlockLevel,
                 applyEffect: () => { globalState.metaLevels.autoBuyUnlockLevel++; updateMetaUpgradeButtonsIfVisible(); },
                 canPurchase: () => globalState.metaLevels.autoBuyUnlockLevel < globalState.tvStates.length,
                 getDescription: (gs, l, c) => {
                     if (l >= gs.tvStates.length) { return `<strong>Auto-Buyer</strong><br>All unlocked TVs have<br>auto-buy available.`; }
                     const tvToUnlock = gs.tvStates[l];
                     if (!tvToUnlock) return `<strong>Auto-Buyer</strong><br>Purchase more TVs to upgrade.`;
                     return `<strong>Auto-Buyer</strong><br>Lv ${l}: Unlocks auto-buyer<br>for TV #${tvToUnlock.id + 1}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`;
                 }
             },
        ];

        // --- Upgrade Calculation Functions ---
        function deriveTvHitValue(tvState, level) { return Math.max(1, Math.ceil(1 + level * 1.5)); }
        function deriveTvSpeedFactor(tvState, level) { return Math.min(3.0, (1 + level * 0.04) * tvState.baseSpeedFactorMeta); }
        function deriveTvCornerFlatBonus(tvState, level) { return Math.max(0, Math.floor(2000 + level * 50 + Math.pow(level, 1.55) * 50)); }
        function deriveTvCornerMultiplier(tvState, level) { return 1.0 + level * 0.10; }
        function deriveTvCollisionBonus(tvState, level) { return Math.max(0, Math.floor(50 + level * 1.5 + Math.pow(level, 1.5))); }
        function getCurrentTvSpeed(tvState) { return BASE_SPEED_CONSTANT * deriveTvSpeedFactor(tvState, tvState.upgrades.speed); }
        function deriveMetaStaticChargeMult(level) { return 1 + level * 0.07; }
        function deriveMetaBaseSpeedFactor(level) { return 1 + level * 0.05; } // FIX: Increased from 0.03
        function deriveMetaBaseMaxBoxes(level) { return 2 + level; }
        function deriveSynergyBonusPerTv(level) { return level > 0 ? (level * 0.008) : 0; } // FIX: Increased from 0.005
        function deriveSynergyBonus(level) { const perTvBonus = deriveSynergyBonusPerTv(level); const numTvs = globalState?.tvStates?.length ?? 0; return 1.0 + (numTvs * perTvBonus); }
        function deriveCornerBetMultiplier(level) { if (level <= 0) return 0; return 8 + level * 2; }

        // --- Apply Upgrades ---
        function recalculateDerivedTvState(tvState) {
            tvState.hitValue = deriveTvHitValue(tvState, tvState.upgrades.hitValue);
            tvState.cornerHitBaseBonus = deriveTvCornerFlatBonus(tvState, tvState.upgrades.cornerBonusFlat);
            tvState.cornerHitMultiplier = deriveTvCornerMultiplier(tvState, tvState.upgrades.cornerMultiplier);
            tvState.boxCollisionValue = deriveTvCollisionBonus(tvState, tvState.upgrades.boxCollisionValue);
            // Apply meta speed factor when recalculating derived state
            tvState.baseSpeedFactorMeta = deriveMetaBaseSpeedFactor(globalState.metaLevels.baseSpeed);
        }
        function recalculateGlobalSynergy() { globalState.synergyBonus = deriveSynergyBonus(globalState.metaLevels.tvSynergyBonus); }
        function applyMetaUpgradesToTv(tvState) {
            // This function now primarily handles calling recalculateDerivedTvState which includes meta speed factor
            recalculateDerivedTvState(tvState);
            // Optionally resize if needed, though usually done separately
             // resizeTvScreen(tvState); // Can uncomment if needed, but recalculate handles speed factor now
        }
        function updateAllTvsPostMeta() {
            globalState.maxBoxesPerTv = deriveMetaBaseMaxBoxes(globalState.metaLevels.baseMaxBoxes);
            // Recalculate synergy first as it depends on TV count
            recalculateGlobalSynergy();
            // Apply meta speed factor and recalculate derived state for each TV
            globalState.tvStates.forEach(tv => {
                applyMetaUpgradesToTv(tv);
                checkAndAdjustBoxPositions(tv.index);
            });
            // No need to recalculate synergy again here
            updateAllTvGlows();
        }


        // --- Upgrade UI & Modal Logic ---
        function openUpgradeModal(tvIndex = -1) {
            selectedTvIndex = tvIndex;
            modalUpgradesContainer.innerHTML = '';
            modalRebootContainer.innerHTML = '';
            modalBuyAmountContainer.innerHTML = '';
            if (modalTvOptionsContainer) modalTvOptionsContainer.innerHTML = '';

            if (tvIndex !== -1) {
                const tvState = globalState.tvStates[tvIndex]; if (!tvState) return;
                modalTitle.textContent = `TV #${tvState.id + 1} Upgrades`;
                updateModalTvStats(tvState);

                if (modalTvOptionsContainer && tvIndex < globalState.metaLevels.autoBuyUnlockLevel) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.classList.add('buy-amount-button');
                    if (tvState.isAutoBuyActive) toggleBtn.classList.add('active');
                    toggleBtn.textContent = `Auto-Buy: ${tvState.isAutoBuyActive ? 'ON' : 'OFF'}`;
                    toggleBtn.onclick = () => {
                        tvState.isAutoBuyActive = !tvState.isAutoBuyActive;
                        toggleBtn.textContent = `Auto-Buy: ${tvState.isAutoBuyActive ? 'ON' : 'OFF'}`;
                        toggleBtn.classList.toggle('active');
                        saveGame();
                    };
                    modalTvOptionsContainer.appendChild(toggleBtn);
                }

                renderBuyAmountButtons();
                renderUpgradeSection(tvUpgrades, modalUpgradesContainer, 'hit', tvIndex);
            } else {
                modalTitle.textContent = 'Meta Upgrades & Reboot';
                modalTvStats.textContent = `Static Charges: ${formatScore(globalState.systemStaticCharges)}`;
                renderUpgradeSection(metaUpgrades, modalUpgradesContainer, 'meta');

                const potentialGain = calculateStaticChargeGain(globalState.lifetimeSessionHits);
                if (potentialGain > 0 || globalState.hasRebootedOnce) {
                    const rebootTemplate = document.getElementById('reboot-section-template');
                    if (rebootTemplate) {
                        const clonedReboot = rebootTemplate.firstElementChild.cloneNode(true);
                        const rebootBtn = clonedReboot.querySelector('#reboot-button');
                        if (rebootBtn) { rebootBtn.onclick = executeReboot; }
                        modalRebootContainer.appendChild(clonedReboot);
                        hitsThresholdCache = {};
                        updateRebootPreviewIfVisible();
                    } else { console.error("Reboot template not found!"); }
                }
            }
            upgradeModal.classList.add('show');
        }
        function closeUpgradeModal() { upgradeModal.classList.remove('show'); selectedTvIndex = -1; updateAllTvGlows(); }
        function renderBuyAmountButtons() {
            modalBuyAmountContainer.innerHTML = ''; const amounts = [1, 10, 100, 'max'];
            amounts.forEach(amount => {
                const btn = document.createElement('button'); btn.classList.add('buy-amount-button'); btn.textContent = `${amount === 'max' ? 'Max' : 'x'+amount}`; btn.dataset.amount = amount;
                if (selectedBuyAmount === amount || (selectedBuyAmount === Infinity && amount === 'max')) { btn.classList.add('active'); }
                btn.onclick = () => setBuyAmount(amount); modalBuyAmountContainer.appendChild(btn);
            });
        }
        function setBuyAmount(amount) {
            selectedBuyAmount = (amount === 'max') ? Infinity : parseInt(amount);
            globalState.selectedBuyAmount = (amount === 'max') ? 'max' : selectedBuyAmount;
            const buttons = modalBuyAmountContainer.querySelectorAll('.buy-amount-button');
            buttons.forEach(btn => { const btnAmount = btn.dataset.amount; const isActive = (selectedBuyAmount === Infinity && btnAmount === 'max') || (selectedBuyAmount === parseInt(btnAmount)); btn.classList.toggle('active', isActive); });
            updateSelectedTvUpgradeButtons();
        }

        function calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex) {
            const amountToTry = selectedBuyAmount;
            const currentLevel = upgrade.getLevel(tvState);
            let totalCost = 0; let levelsBought = 0; let maxLevelReached = false;
            let nextLevelCost = 0;

            let maxLevel;
            if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
            else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
            else maxLevel = upgrade.maxLevel;

            const isCurrentlyMaxed = (maxLevel !== undefined && currentLevel >= maxLevel) || !(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true);

            if (isCurrentlyMaxed) {
                return { levels: 0, totalCost: 0, affordable: false, isMaxLevel: true, nextLevelCost: 0 };
            }

            nextLevelCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex);
            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;
            const flooredScore = Math.floor(currentScore);

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + levelsBought;
                if (maxLevel !== undefined && levelToCheck >= maxLevel) { maxLevelReached = true; break; }
                if (!(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, levelToCheck) : true)) { maxLevelReached = true; break; }
                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);
                if (flooredScore >= totalCost + costForThisLevel) {
                    totalCost += costForThisLevel; levelsBought++;
                } else { break; }
            }
            const affordable = levelsBought > 0;
            return { levels: levelsBought, totalCost: totalCost, affordable: affordable, isMaxLevel: isCurrentlyMaxed || (maxLevelReached && levelsBought === 0), nextLevelCost: nextLevelCost };
        }

        function renderUpgradeSection(upgrades, container, currencyType, tvIndex = -1) {
             if (!container) return; container.innerHTML = '';
             const isTvModal = currencyType === 'hit' && tvIndex !== -1;
             const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
             const stateForLevel = tvState ?? globalState;
             const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemStaticCharges;

             upgrades.forEach(upgrade => {
                 const currentLevel = upgrade.getLevel(stateForLevel);
                 let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false, nextLevelCost: 0 };
                 let descriptionText = ''; let currencyClass = currencyType;
                 let costToShow = 0; let levelText = ''; let isCurrentlyMaxed = false;

                 let maxLevelCheck;
                 if (upgrade.id === 'multiBox' && tvState) maxLevelCheck = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(stateForLevel);
                 else maxLevelCheck = upgrade.maxLevel;

                 isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                 if (!isCurrentlyMaxed && typeof upgrade.canPurchase === 'function') {
                     isCurrentlyMaxed = !upgrade.canPurchase(stateForLevel, currentLevel);
                 }

                 if (isTvModal && tvState) {
                     bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                     isCurrentlyMaxed = bulkInfo.isMaxLevel;
                     descriptionText = upgrade.getDescription(tvState, currentLevel, isCurrentlyMaxed);
                     if (!isCurrentlyMaxed) {
                         if (bulkInfo.affordable && bulkInfo.levels > 0) {
                             costToShow = bulkInfo.totalCost;
                             if (bulkInfo.levels > 1) levelText = ` (x${bulkInfo.levels})`;
                         } else { costToShow = bulkInfo.nextLevelCost; }
                     }
                 } else {
                     const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                     costToShow = cost;
                     bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                     bulkInfo.isMaxLevel = isCurrentlyMaxed;
                     descriptionText = upgrade.getDescription(globalState, currentLevel, cost, isCurrentlyMaxed);
                 }

                 const btn = document.createElement('button');
                 btn.classList.add('upgrade-button');
                 btn.dataset.upgradeId = upgrade.id;
                 btn.dataset.currencyType = currencyType;
                 if (tvIndex >= 0) btn.dataset.tvIndex = tvIndex;

                 btn.innerHTML = `<div class="upgrade-description">${descriptionText}</div>`;
                 if (!isCurrentlyMaxed && currencyType === 'hit') {
                     btn.innerHTML += `<div class="upgrade-cost ${currencyClass}">Cost: ${formatScore(costToShow)}${levelText}</div>`;
                 }
                 if(!isCurrentlyMaxed && currencyType === 'meta' && !descriptionText.includes('upgrade-cost meta')) {
                     btn.innerHTML += `<div class="upgrade-cost ${currencyClass}">Cost: ${formatScore(costToShow)}</div>`;
                 }

                 btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                 btn.onclick = () => buyUpgrade(upgrade.id, currencyType, tvIndex);
                 container.appendChild(btn);
             });
        }

        function updateUpgradeButtonsInSection(upgrades, container, currencyType, tvIndex = -1) {
            if (!container) return;
            const isTvModal = currencyType === 'hit' && tvIndex !== -1;
            const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
            const stateForLevel = tvState ?? globalState;
            const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemStaticCharges;

            upgrades.forEach(upgrade => {
                const btn = container.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
                if (btn) {
                    const currentLevel = upgrade.getLevel(stateForLevel);
                    let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false, nextLevelCost: 0 };
                    let descriptionText = ''; let currencyClass = currencyType;
                    let costToShow = 0; let levelText = ''; let isCurrentlyMaxed = false;

                    let maxLevelCheck;
                    if (upgrade.id === 'multiBox' && tvState) maxLevelCheck = globalState.maxBoxesPerTv;
                    else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(stateForLevel);
                    else maxLevelCheck = upgrade.maxLevel;

                     isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                     if (!isCurrentlyMaxed && typeof upgrade.canPurchase === 'function') {
                        isCurrentlyMaxed = !upgrade.canPurchase(stateForLevel, currentLevel);
                     }

                    const descDiv = btn.querySelector('.upgrade-description');
                    let costDiv = btn.querySelector('.upgrade-cost');

                    if (isTvModal && tvState) {
                        bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                        isCurrentlyMaxed = bulkInfo.isMaxLevel;
                        descriptionText = upgrade.getDescription(tvState, currentLevel, isCurrentlyMaxed);
                        if (descDiv) descDiv.innerHTML = descriptionText;

                        if (!isCurrentlyMaxed) {
                            if (bulkInfo.affordable && bulkInfo.levels > 0) {
                                costToShow = bulkInfo.totalCost;
                                if (bulkInfo.levels > 1) levelText = ` (x${bulkInfo.levels})`;
                            } else { costToShow = bulkInfo.nextLevelCost; }
                            if (!costDiv) {
                                costDiv = document.createElement('div');
                                costDiv.classList.add('upgrade-cost', currencyClass);
                                btn.appendChild(costDiv);
                            }
                            costDiv.innerHTML = `Cost: ${formatScore(costToShow)}${levelText}`;
                            costDiv.style.display = '';
                        } else { if (costDiv) costDiv.style.display = 'none'; }
                    } else { // Meta upgrades
                        const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                        costToShow = cost;
                        bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                        bulkInfo.isMaxLevel = isCurrentlyMaxed;
                        descriptionText = upgrade.getDescription(globalState, currentLevel, cost, isCurrentlyMaxed);
                        if (descDiv) descDiv.innerHTML = descriptionText;

                         if(!isCurrentlyMaxed && !descriptionText.includes('upgrade-cost meta')) {
                             if (!costDiv) {
                                 costDiv = document.createElement('div');
                                 costDiv.classList.add('upgrade-cost', currencyClass);
                                 btn.appendChild(costDiv);
                             }
                             costDiv.innerHTML = `Cost: ${formatScore(costToShow)}`;
                             costDiv.style.display = '';
                         } else if (isCurrentlyMaxed && costDiv) {
                             costDiv.style.display = 'none';
                         }
                    }
                    btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                }
            });
        }

        function buyUpgrade(id, currencyType, tvIndex = -1) {
            const upgrades = currencyType === 'hit' ? tvUpgrades : metaUpgrades;
            const upgrade = upgrades.find(u => u.id === id); if (!upgrade) return;

            const isTvUpgrade = currencyType === 'hit' && tvIndex !== -1;
            const amountToTry = isTvUpgrade ? selectedBuyAmount : 1;
            const stateToModify = isTvUpgrade ? globalState.tvStates[tvIndex] : globalState;
            if (!stateToModify) { console.error("Invalid state for upgrade:", id, currencyType, tvIndex); return; }

            const scoreRef = currencyType === 'hit' ? 'totalSessionHits' : 'systemStaticCharges';
            const currentScore = globalState[scoreRef];
            let currentLevel = upgrade.getLevel(stateToModify);
            let totalCost = 0; let levelsToBuy = 0;
            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;
            const flooredScore = Math.floor(currentScore);

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + levelsToBuy;
                 let maxLevel;
                 if (upgrade.id === 'multiBox' && isTvUpgrade) maxLevel = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(stateToModify);
                 else maxLevel = upgrade.maxLevel;
                if (maxLevel !== undefined && levelToCheck >= maxLevel) break;
                if (!(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(stateToModify, levelToCheck) : true)) break;
                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);
                if (flooredScore >= totalCost + costForThisLevel) {
                    totalCost += costForThisLevel; levelsToBuy++;
                } else { break; }
            }

            if (levelsToBuy > 0) {
                globalState[scoreRef] -= totalCost;

                if (isTvUpgrade) {
                    if (upgrade.id === 'multiBox') {
                        upgrade.applyEffect(stateToModify, tvIndex, levelsToBuy);
                    } else {
                         for(let k=0; k<levelsToBuy; k++) { upgrade.applyEffect(stateToModify, tvIndex); }
                    }
                    recalculateDerivedTvState(stateToModify); // Apply TV upgrade effects
                    updateModalTvStats(stateToModify);
                    updateSelectedTvUpgradeButtons();
                    updateTvGlow(tvIndex);
                } else { // Meta Upgrade
                     for(let k=0; k<levelsToBuy; k++) { upgrade.applyEffect(stateToModify, tvIndex); }
                     // Re-apply relevant global effects after meta upgrade
                     if (upgrade.id === 'metaTvSynergyBonus' || upgrade.id === 'metaAddTv') {
                         recalculateGlobalSynergy(); // Recalculate synergy if TV count or synergy level changes
                     }
                     if (upgrade.id === 'metaBaseMaxBoxes' || upgrade.id === 'metaBaseSpeed') {
                         updateAllTvsPostMeta(); // Apply speed/max box changes to all TVs
                     }
                     if (upgrade.id === 'metaAddTv') checkMetaButtonVisibility(); // Show/hide meta button if needed
                     if (upgrade.id === 'metaBaseMaxBoxes') updateSelectedTvUpgradeButtons(); // Update TV modal if open

                     modalTvStats.textContent = `Static Charges: ${formatScore(globalState.systemStaticCharges)}`;
                     hitsThresholdCache = {};
                     updateMetaUpgradeButtonsIfVisible();
                     updateRebootPreviewIfVisible();
                     updateAllTvGlows();
                }
                updateTotalHitsDisplay();
                saveGame();
            } else {
                 const nextCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex);
                 console.log(`Cannot afford ${amountToTry === Infinity ? 1 : amountToTry} level(s) of ${id}. Need ${formatScore(nextCost)}, have ${formatScore(currentScore)}`);
            }
        }

        // --- Button Updates ---
        function updateSelectedTvUpgradeButtons() { if (selectedTvIndex !== -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(tvUpgrades, modalUpgradesContainer, 'hit', selectedTvIndex); } }
        function updateMetaUpgradeButtonsIfVisible() { if (selectedTvIndex === -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(metaUpgrades, modalUpgradesContainer, 'meta'); } }

        // --- Reboot Logic ---
        function canCurrentlyReboot() { return globalState.systemStaticCharges > 0 || globalState.hasRebootedOnce || calculateStaticChargeGain(globalState.lifetimeSessionHits) > 0; }
        function checkMetaButtonVisibility() { metaMenuButton.classList.toggle('show', canCurrentlyReboot()); }
        function findHitsThreshold(targetGain) {
            if (targetGain <= 0) return 0;
            if (hitsThresholdCache[targetGain] !== undefined) return hitsThresholdCache[targetGain];

            let lowerBound = 0; let upperBound = hitsThresholdCache[targetGain-1] ?? REBOOT_MIN_HITS_FOR_FIRST_CHARGE;
            let iterations = 0;
            while (calculateStaticChargeGain(upperBound) < targetGain && iterations < 50 && upperBound < FIND_THRESHOLD_MAX_HITS) {
                lowerBound = upperBound; upperBound = Math.max(upperBound + 1, Math.floor(upperBound * 5)); iterations++;
            }
             upperBound = Math.min(upperBound, FIND_THRESHOLD_MAX_HITS);
             if (calculateStaticChargeGain(upperBound) < targetGain || upperBound >= FIND_THRESHOLD_MAX_HITS) { hitsThresholdCache[targetGain] = Infinity; return Infinity; }

            let bestGuess = upperBound; iterations = 0;
            while (lowerBound <= upperBound && iterations < FIND_THRESHOLD_MAX_ITERATIONS) {
                const mid = lowerBound + Math.floor((upperBound - lowerBound) / 2);
                if (mid <= lowerBound && mid < upperBound) break;
                const gainAtMid = calculateStaticChargeGain(mid);
                if (gainAtMid >= targetGain) { bestGuess = mid; upperBound = mid - 1; }
                else { lowerBound = mid + 1; }
                iterations++;
            }
             if (iterations >= FIND_THRESHOLD_MAX_ITERATIONS) console.warn(`findHitsThreshold exceeded max iterations for targetGain ${targetGain}. Returning best guess: ${bestGuess}`);
            hitsThresholdCache[targetGain] = bestGuess; return bestGuess;
        }
        function updateRebootPreviewIfVisible() {
            if (selectedTvIndex !== -1 || !upgradeModal.classList.contains('show')) return;
            const rebootSection = modalRebootContainer.querySelector('#reboot-section'); if (!rebootSection) return;
            const rebootGainPreview = rebootSection.querySelector('#reboot-gain-preview');
            const rebootButton = rebootSection.querySelector('#reboot-button');
            const progressContainer = rebootSection.querySelector('#reboot-progress-container');
            const progressBar = rebootSection.querySelector('#reboot-progress-bar');
            const progressText = rebootSection.querySelector('#reboot-progress-text');
            if (!rebootGainPreview || !rebootButton || !progressContainer || !progressBar || !progressText) return;

            const currentLifetimeHits = globalState.lifetimeSessionHits;
            const totalPotentialGain = calculateStaticChargeGain(currentLifetimeHits);
            rebootGainPreview.textContent = `Gain ~${formatScore(totalPotentialGain)} Static Charges (from ${formatScore(currentLifetimeHits)} total Hits)`;
            rebootButton.disabled = totalPotentialGain <= 0;

            let hitsForCurrentGain = 0; let hitsForNextGain = Infinity; let hitsRemaining = 0; let progressPercent = 0; let displayText = "";

            if (totalPotentialGain === 0) {
                hitsForNextGain = findHitsThreshold(1);
                if (hitsForNextGain === Infinity || hitsForNextGain <= REBOOT_MIN_HITS_FOR_FIRST_CHARGE) {
                     hitsRemaining = REBOOT_MIN_HITS_FOR_FIRST_CHARGE - currentLifetimeHits;
                     progressPercent = Math.min(100, Math.max(0, (currentLifetimeHits / REBOOT_MIN_HITS_FOR_FIRST_CHARGE) * 100));
                     displayText = `${formatScore(Math.max(0, hitsRemaining))} Hits for first charge`;
                } else {
                     hitsRemaining = hitsForNextGain - currentLifetimeHits;
                     progressPercent = Math.min(100, Math.max(0, (currentLifetimeHits / hitsForNextGain) * 100));
                     displayText = `${formatScore(Math.max(0, hitsRemaining))} Hits for first charge`;
                }
                 progressBar.style.width = `${progressPercent}%`; progressText.textContent = displayText; progressContainer.style.display = 'block';
            } else {
                const targetGain = totalPotentialGain + 1;
                hitsForCurrentGain = findHitsThreshold(totalPotentialGain); hitsForNextGain = findHitsThreshold(targetGain);
                if (hitsForNextGain === Infinity || hitsForNextGain <= hitsForCurrentGain) {
                    progressPercent = 100; displayText = `Next Threshold Far Away`;
                     progressBar.style.width = '100%'; progressText.textContent = displayText; progressContainer.style.display = 'block';
                } else {
                    const hitsInRange = hitsForNextGain - hitsForCurrentGain;
                    const currentProgressInHits = currentLifetimeHits - hitsForCurrentGain;
                    hitsRemaining = hitsForNextGain - currentLifetimeHits;
                    progressPercent = Math.min(100, Math.max(0, (currentProgressInHits / hitsInRange) * 100));
                    displayText = `${formatScore(Math.max(0, hitsRemaining))} Hits for next charge`;
                     progressBar.style.width = `${progressPercent}%`; progressText.textContent = displayText; progressContainer.style.display = 'block';
                }
            }
        }
        function calculateStaticChargeGain(totalLifetimeHits) {
            if (totalLifetimeHits < REBOOT_MIN_HITS_FOR_FIRST_CHARGE) return 0;
            const metaMultiplier = deriveMetaStaticChargeMult(globalState.metaLevels.staticChargeGain);
            const baseGain = Math.pow(totalLifetimeHits / REBOOT_MIN_HITS_FOR_FIRST_CHARGE, 0.45) * 1.5;
            const logBonus = Math.log10(totalLifetimeHits / REBOOT_MIN_HITS_FOR_FIRST_CHARGE + 1) * 0.5;
            const gain = Math.floor((baseGain + logBonus) * metaMultiplier);
            return Math.max(0, gain);
        }
        function executeReboot() {
             const staticChargesGained = calculateStaticChargeGain(globalState.lifetimeSessionHits);
             if (staticChargesGained <= 0 && globalState.lifetimeSessionHits < REBOOT_MIN_HITS_FOR_FIRST_CHARGE) {
                 showNotification("Not enough lifetime Hits for Static Charges"); return;
             }
              if (!confirm(`Reboot: Gain ${formatScore(staticChargesGained)} Static Charges?\n\nResets session Hits & TV Upgrades.\nKeeps Static Charges, Meta Upgrades & Unlocked TVs.`)) {
                 return;
             }

             closeUpgradeModal();
             showNotification(`Rebooted! +${formatScore(staticChargesGained)} Static Charges`);

             globalState.systemStaticCharges += staticChargesGained;
             globalState.hasRebootedOnce = true;
             globalState.totalSessionHits = 0;
             globalState.lifetimeSessionHits = 0;
             globalState.screenBurnCooldownEndTimestamp = 0;
             globalState.isCornerBetActive = false;
             globalState.cornerBetAmount = 0;
             globalState.cornerBetActivationTimestamp = null;

             boxCollisionTimers = {}; hitsThresholdCache = {}; devSpeedFactor = 1;
             if(document.getElementById('dev-speed-input')) document.getElementById('dev-speed-input').value = 1;

             globalState.tvStates.forEach((tvState, index) => {
                 Object.keys(tvState.upgrades).forEach(key => { tvState.upgrades[key] = 0; });
                 clearTvScreenBoxes(index);
                 tvState.boxes = []; tvState.nextBoxId = 0; tvState.lastCornerHitTimestamp = null;
                 recalculateDerivedTvState(tvState); // Recalculates with current meta levels
                 // No need to call applyMetaUpgradesToTv here, it's handled by recalculate
                 addBoxToTv(index); resizeTvScreen(tvState); checkAndAdjustBoxPositions(index);
            });

             recalculateGlobalSynergy(); // Recalculate based on potentially changed TV count (though usually static on reboot)
             updateTotalHitsDisplay(); updateAllTvGlows();
             checkMetaButtonVisibility(); updateScreenBurnButtonState(Date.now());
             updateCornerBetButtonVisibility(); updateCornerBetButtonState();
             saveGame();
         }

         // --- Screen Burn Ability ---
        function updateScreenBurnButtonVisibility() {
            const isVisible = globalState && globalState.metaLevels.screenBurnLevel > 0;
            screenBurnButton.style.display = isVisible ? 'flex' : 'none';
        }
        function updateScreenBurnButtonState(now) {
            if (!globalState || globalState.metaLevels.screenBurnLevel <= 0) {
                 screenBurnButton.style.display = 'none'; return;
            }
             updateScreenBurnButtonVisibility();
            const cooldownEndTime = globalState.screenBurnCooldownEndTimestamp || 0;
            if (now < cooldownEndTime) {
                screenBurnButton.disabled = true;
                const remainingSeconds = Math.ceil((cooldownEndTime - now) / 1000);
                const minutes = Math.floor(remainingSeconds / 60); const seconds = remainingSeconds % 60;
                if(screenBurnCooldownText) screenBurnCooldownText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                screenBurnButton.disabled = false;
                if(screenBurnCooldownText) screenBurnCooldownText.textContent = '';
            }
        }
        function activateScreenBurn() {
            const now = Date.now();
            if (!globalState || globalState.metaLevels.screenBurnLevel <= 0) return;
            if (now < (globalState.screenBurnCooldownEndTimestamp || 0)) return;
            if (globalState.isCornerBetActive) {
                showNotification("Cannot activate Screen Burn during Corner Bet!");
                return;
            }

            const numLogosToBurn = globalState.metaLevels.screenBurnLevel;
            if (numLogosToBurn <= 0) return;

            const availableLogos = [];
            globalState.tvStates.forEach(tv => {
                tv.boxes.forEach(box => {
                    if (box.element && (box.burnEndTime === null || now >= box.burnEndTime)) {
                        availableLogos.push({ box, tvIndex: tv.index });
                    }
                });
            });
            if (availableLogos.length === 0) { showNotification("No logos available to burn!"); return; }

            shuffleArray(availableLogos);
            const logosToAffect = availableLogos.slice(0, numLogosToBurn);
            logosToAffect.forEach(item => {
                const box = item.box; box.burnEndTime = now + SCREEN_BURN_DURATION_MS;
                if (box.element) {
                     box.element.classList.add('screen-burn-effect');
                     box.element.style.setProperty('--tx', `${box.x}px`); box.element.style.setProperty('--ty', `${box.y}px`);
                }
            });

            globalState.screenBurnCooldownEndTimestamp = now + SCREEN_BURN_COOLDOWN_SECONDS * 1000;
            updateScreenBurnButtonState(now);
            showNotification(`Screen Burn Activated! ${logosToAffect.length} logo${logosToAffect.length !== 1 ? 's' : ''} affected.`);
            saveGame();
        }

        // --- Corner Bet Ability ---
        function updateCornerBetButtonVisibility() {
             const isVisible = globalState && globalState.metaLevels.cornerBetLevel > 0;
             cornerBetButton.style.display = isVisible ? 'flex' : 'none';
        }
        function updateCornerBetButtonState() {
             if (!globalState || globalState.metaLevels.cornerBetLevel <= 0) {
                 cornerBetButton.style.display = 'none'; return;
             }
             updateCornerBetButtonVisibility();
             const isDisabled = globalState.isCornerBetActive || globalState.totalSessionHits <= 0;
             cornerBetButton.disabled = isDisabled;
             cornerBetButton.classList.toggle('bet-active', globalState.isCornerBetActive);
         }
        function activateCornerBet() {
             if (!globalState || globalState.metaLevels.cornerBetLevel <= 0) { showNotification("Corner Bet upgrade required!"); return; }
             if (globalState.isCornerBetActive) { showNotification("Corner Bet already active!"); return; }
             if (globalState.totalSessionHits <= 0) { showNotification("Need Hits to place a bet!"); return; }
             const now = Date.now();
             if (now < (globalState.screenBurnCooldownEndTimestamp || 0)) { showNotification("Cannot activate Corner Bet during Screen Burn cooldown!"); return; }
             let anyBurning = false;
             globalState.tvStates.forEach(tv => tv.boxes.forEach(b => { if(b.burnEndTime && now < b.burnEndTime) anyBurning = true; }));
             if (anyBurning) { showNotification("Cannot activate Corner Bet while logos are burning!"); return; }

             globalState.cornerBetAmount = globalState.totalSessionHits;
             globalState.isCornerBetActive = true;
             globalState.cornerBetActivationTimestamp = Date.now();
             updateCornerBetButtonState();
             showNotification(`Bet Placed: ${formatScore(globalState.cornerBetAmount)} Hits! Next hit must be a corner within ${CORNER_BET_TIMEOUT_MS/1000}s.`);
             saveGame();
         }
        function resolveCornerBet(isWin) {
             if (!globalState || !globalState.isCornerBetActive) return;

             const betAmount = globalState.cornerBetAmount;
             const multiplier = deriveCornerBetMultiplier(globalState.metaLevels.cornerBetLevel);
             let message = ""; let finalAmount = 0;

             if (isWin) {
                 const winnings = Math.floor(betAmount * multiplier);
                 const netGain = winnings - betAmount;
                 globalState.totalSessionHits = winnings;
                 globalState.lifetimeSessionHits += Math.max(0, netGain);
                 message = "CORNER BET WIN!"; finalAmount = winnings;
                 showBetResultOverlay(message, finalAmount, true);
             } else {
                 globalState.totalSessionHits = 0;
                 message = "CORNER BET LOST!"; finalAmount = betAmount;
                 showBetResultOverlay(message, finalAmount, false);
             }

             globalState.isCornerBetActive = false;
             globalState.cornerBetAmount = 0;
             globalState.cornerBetActivationTimestamp = null;

             updateCornerBetButtonState();
             updateTotalHitsDisplay();
             updateAllTvGlows();
             if (upgradeModal.classList.contains('show')) {
                 hitsThresholdCache = {};
                 updateSelectedTvUpgradeButtons();
                 updateMetaUpgradeButtonsIfVisible();
                 updateRebootPreviewIfVisible();
             }
             saveGame();
         }

        // --- Saving and Loading ---
        function saveGame() {
            try {
                const now = Date.now();
                 if (document.hidden && (now - lastSaveTime < 4000)) return;
                 if (!globalState) { console.warn("Attempted to save with null globalState."); return; }

                globalState.lastSaveTimestamp = now;
                lastSaveTime = now;
                globalState.version = SAVE_VERSION;

                const amountToSave = (selectedBuyAmount === Infinity) ? 'max' : selectedBuyAmount;
                const stateToSave = JSON.parse(JSON.stringify({...globalState, selectedBuyAmount: amountToSave}, (key, value) => {
                    if (key === 'elements' || key === 'element' || key === 'resizeRetryTimeout' || key === 'adjustRetryTimeout' || key === 'burnEndTime') return undefined;
                     if (['x', 'y', 'vx', 'vy'].includes(key)) { return (typeof value === 'number' && !isNaN(value)) ? value : 0; }
                     if (key === 'lastCornerHitTimestamp') { return (typeof value === 'number' && value > 0) ? value : null; }
                     if (key === 'screenBurnCooldownEndTimestamp') { return (typeof value === 'number' && value > 0) ? value : 0; }
                     if (key === 'isCornerBetActive') { return typeof value === 'boolean' ? value : false; }
                     if (key === 'cornerBetAmount') { return (typeof value === 'number' && value >= 0) ? value : 0; }
                     if (key === 'cornerBetActivationTimestamp') { return (typeof value === 'number' && value > 0) ? value : null; }
                    return value;
                }));
                localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));

            } catch (e) {
                console.error("Save Error:", e);
                showNotification("Save Error!");
            }
        }

        function loadGame() {
            const savedData = localStorage.getItem(SAVE_KEY);
            let needsInitialization = true;
            let offlineGains = 0;

            devSpeedFactor = 1;
            const speedInput = document.getElementById('dev-speed-input');
            if (speedInput) speedInput.value = devSpeedFactor;

            if (savedData) {
                try {
                    const loadedState = JSON.parse(savedData);

                    if (loadedState.version !== SAVE_VERSION) {
                        console.warn(`Save data version mismatch (Save: ${loadedState.version || 'Unknown'}, Game: ${SAVE_VERSION}). Resetting.`);
                        localStorage.removeItem(SAVE_KEY); needsInitialization = true;
                    } else {
                        const isValidStructure = loadedState && typeof loadedState.systemStaticCharges === 'number' && Array.isArray(loadedState.tvStates) &&
                                                loadedState.metaLevels && loadedState.metaLevels.hasOwnProperty('screenBurnLevel') &&
                                                loadedState.metaLevels.hasOwnProperty('cornerBetLevel') &&
                                                loadedState.hasOwnProperty('isCornerBetActive') &&
                                                loadedState.hasOwnProperty('cornerBetAmount') &&
                                                loadedState.hasOwnProperty('cornerBetActivationTimestamp') &&
                                                loadedState.hasOwnProperty('screenBurnCooldownEndTimestamp');

                        if (isValidStructure) {
                            globalState = createDefaultGlobalState();
                            globalState = deepMerge(globalState, loadedState);

                            globalState.totalSessionHits = Number(globalState.totalSessionHits) || 0;
                            globalState.lifetimeSessionHits = Number(globalState.lifetimeSessionHits) || globalState.totalSessionHits;
                            globalState.systemStaticCharges = Number(globalState.systemStaticCharges) || 0;
                            globalState.hasRebootedOnce = Boolean(globalState.hasRebootedOnce);
                            globalState.lastSaveTimestamp = Number(globalState.lastSaveTimestamp) || null;
                            globalState.screenBurnCooldownEndTimestamp = Number(globalState.screenBurnCooldownEndTimestamp) || 0;
                            globalState.isCornerBetActive = Boolean(globalState.isCornerBetActive);
                            globalState.cornerBetAmount = Number(globalState.cornerBetAmount) || 0;
                            globalState.cornerBetActivationTimestamp = Number(globalState.cornerBetActivationTimestamp) || null;
                            if (globalState.isCornerBetActive) {
                                console.warn("Loaded game with an active corner bet. Resetting bet state.");
                                globalState.isCornerBetActive = false;
                                globalState.cornerBetAmount = 0;
                                globalState.cornerBetActivationTimestamp = null;
                            }

                            const defaultMetaKeys = Object.keys(createDefaultGlobalState().metaLevels);
                            defaultMetaKeys.forEach(key => {
                                if (!globalState.metaLevels.hasOwnProperty(key)) {
                                    console.warn(`Meta level ${key} missing from save, initializing to 0.`);
                                    globalState.metaLevels[key] = 0;
                                } else { globalState.metaLevels[key] = Number(globalState.metaLevels[key]) || 0; }
                            });

                            globalState.nextTvId = Math.max(globalState.nextTvId || 0, (globalState.tvStates.reduce((max, tv) => Math.max(max, tv.id ?? -1), -1) + 1));
                            selectedBuyAmount = globalState.selectedBuyAmount || 1;
                            if (selectedBuyAmount === 'max') selectedBuyAmount = Infinity;
                            else selectedBuyAmount = parseInt(selectedBuyAmount) || 1;

                            if (globalState.lastSaveTimestamp && typeof globalState.lastSaveTimestamp === 'number') {
                                const currentTime = Date.now();
                                let offlineTimeMs = currentTime - globalState.lastSaveTimestamp;
                                offlineTimeMs = Math.max(0, offlineTimeMs); offlineTimeMs = Math.min(offlineTimeMs, MAX_OFFLINE_TIME_MS);
                                if (offlineTimeMs >= MIN_OFFLINE_TIME_MS) {
                                    updateAllTvsPostMeta(); // Apply meta effects before calculating idle
                                    recalculateGlobalSynergy(); // Needed for idle calc
                                    hitsThresholdCache = {};
                                    console.log(`Calculating offline gains for ${Math.round(offlineTimeMs / 1000)} seconds...`);
                                    offlineGains = calculateIdleGains(offlineTimeMs);
                                    if (offlineGains > 0) {
                                        globalState.totalSessionHits += offlineGains;
                                        globalState.lifetimeSessionHits += offlineGains;
                                        console.log(`Offline Gains: ${formatScore(offlineGains)} Hits`);
                                    }
                                } else { console.log("Offline time too short for calculation:", offlineTimeMs, "ms"); }
                            } else { console.log("No valid lastSaveTimestamp found for offline calculation."); }

                            const defaultTvUpgrades = createDefaultTvState(0,0).upgrades;
                            globalState.tvStates.forEach((tv, index) => {
                                tv.index = index;
                                tv.id = Number.isInteger(tv.id) ? tv.id : index;
                                tv.boxes = Array.isArray(tv.boxes) ? tv.boxes : [];
                                tv.boxes.forEach(box => {
                                    box.x = (typeof box.x === 'number' && !isNaN(box.x)) ? box.x : 50; box.y = (typeof box.y === 'number' && !isNaN(box.y)) ? box.y : 50;
                                    box.vx = (typeof box.vx === 'number' && !isNaN(box.vx)) ? box.vx : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                    box.vy = (typeof box.vy === 'number' && !isNaN(box.vy)) ? box.vy : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                    box.element = null; box.burnEndTime = null;
                                });
                                tv.nextBoxId = Math.max(tv.nextBoxId || 0, (tv.boxes.reduce((max, box) => Math.max(max, box.id ?? -1), -1) + 1));
                                tv.lastCornerHitTimestamp = (typeof tv.lastCornerHitTimestamp === 'number' && tv.lastCornerHitTimestamp > 0) ? tv.lastCornerHitTimestamp : null;
                                Object.keys(defaultTvUpgrades).forEach(upgradeKey => {
                                    if (!tv.upgrades || !tv.upgrades.hasOwnProperty(upgradeKey)) {
                                        console.warn(`TV ${tv.id + 1} missing upgrade ${upgradeKey}, initializing to 0.`);
                                        if (!tv.upgrades) tv.upgrades = {}; tv.upgrades[upgradeKey] = 0;
                                    } else { tv.upgrades[upgradeKey] = Number(tv.upgrades[upgradeKey]) || 0; }
                                });
                                // Recalculate derived state for each loaded TV
                                recalculateDerivedTvState(tv);
                            });

                            nextTvId = globalState.nextTvId; boxCollisionTimers = {}; hitsThresholdCache = {};
                            // updateAllTvsPostMeta(); // Already called before idle calc if needed
                            recalculateGlobalSynergy(); // Ensure synergy is correct after loading all TVs
                            showNotification(`Loaded Game State (${SAVE_VERSION})${offlineGains > 0 ? ` (+${formatScore(offlineGains)} Offline Hits)` : ''}`);
                            needsInitialization = false;
                        } else {
                            console.warn(`Save data structure invalid (v${SAVE_VERSION}). Resetting.`);
                            localStorage.removeItem(SAVE_KEY); needsInitialization = true;
                        }
                    }
                } catch (e) {
                    console.error("Load Error:", e); showNotification("Load Error! Resetting.");
                    localStorage.removeItem(SAVE_KEY); needsInitialization = true;
                }
            }

            if (needsInitialization) {
                console.log("Initializing new game state.");
                globalState = createDefaultGlobalState();
                // Initialize first TV correctly
                updateAllTvsPostMeta(); // Sets maxBoxesPerTv, recalculates synergy (1.0)
                addTv(); // Adds the first TV
                selectedBuyAmount = 1; hitsThresholdCache = {};
            }

             recreateAllDomElements(); // Rebuild DOM based on loaded/initialized state
             checkMetaButtonVisibility();
             updateScreenBurnButtonVisibility(); updateScreenBurnButtonState(Date.now());
             updateCornerBetButtonVisibility(); updateCornerBetButtonState();
             updateTotalHitsDisplay(); updateAllTvGlows();
             requestAnimationFrame(handleGlobalResize);
        }

        // --- Utility: Deep Merge ---
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
        function deepMerge(target, source) {
            if (!isObject(target) || !isObject(source)) return source;
            let output = { ...target };
            Object.keys(source).forEach(key => {
                const targetValue = target[key]; const sourceValue = source[key];
                if (sourceValue === undefined) { return; }
                if (sourceValue === null) { output[key] = null; return; }
                if (isObject(sourceValue) && isObject(targetValue)) { output[key] = deepMerge(targetValue, sourceValue); }
                else if (Array.isArray(sourceValue)) {
                    try { output[key] = JSON.parse(JSON.stringify(sourceValue)); }
                    catch (e) { console.error(`Error deep cloning array for key ${key}:`, e); output[key] = sourceValue; }
                } else { output[key] = sourceValue; }
            });
            return output;
        }


        // --- State Initialization ---
        function createDefaultTvState(index, id) {
            const tvState = {
                index: index, id: id, boxes: [], nextBoxId: 0,
                upgrades: { hitValue: 0, speed: 0, cornerBonusFlat: 0, cornerMultiplier: 0, boxCollisionValue: 0 },
                // Derived values will be set by recalculateDerivedTvState
                hitValue: 1, cornerHitBaseBonus: 0, cornerHitMultiplier: 1.0, boxCollisionValue: 0,
                baseSpeedFactorMeta: 1.0, lastCornerHitTimestamp: null,
                screenWidth: 0, screenHeight: 0,
                dynamicBoxWidth: 0, dynamicBoxHeight: 0, elements: null, resizeRetryTimeout: null, adjustRetryTimeout: null,
                isAutoBuyActive: false,
            };
            recalculateDerivedTvState(tvState); // Initialize derived values
            return tvState;
        }
        function createDefaultGlobalState() {
            const now = Date.now();
            return {
                version: SAVE_VERSION, systemStaticCharges: 0, totalSessionHits: 0, lifetimeSessionHits: 0, tvStates: [],
                metaLevels: {
                    staticChargeGain: 0, baseSpeed: 0, baseMaxBoxes: 0, tvSynergyBonus: 0, cornersSuckBonus: 0,
                    screenBurnLevel: 0, cornerBetLevel: 0, autoBuyUnlockLevel: 0
                },
                synergyBonus: 1.0, maxBoxesPerTv: 2, hasRebootedOnce: false, nextTvId: 0, selectedBuyAmount: 1,
                lastSaveTimestamp: now, screenBurnCooldownEndTimestamp: 0,
                isCornerBetActive: false, cornerBetAmount: 0, cornerBetActivationTimestamp: null
            };
        }

        // --- Idle Progress Calculation ---
        function calculateIdleGains(idleTimeMs) {
            if (!globalState || !globalState.tvStates || idleTimeMs <= 0) return 0;
            let totalIdleHitsPerSec = 0;
            const nowForIdle = Date.now();

            // Ensure derived state and synergy are up-to-date before calculation
            // updateAllTvsPostMeta(); // Called in loadGame before this if needed
            // recalculateGlobalSynergy(); // Called in loadGame before this if needed

            globalState.tvStates.forEach(tvState => {
                if (tvState.boxes.length === 0) return;
                 // Ensure TV's derived state reflects current meta levels
                 // recalculateDerivedTvState(tvState); // Should be up-to-date from loadGame/meta purchase

                const tvSpeedFactor = deriveTvSpeedFactor(tvState, tvState.upgrades.speed);
                let tvHitValue = tvState.hitValue; const numBoxes = tvState.boxes.length;

                const cornersSuckLevel = globalState.metaLevels.cornersSuckBonus;
                if (cornersSuckLevel > 0) {
                    const timeToMaxMs = (CORNERS_SUCK_MAX_MULTIPLIER - 1) * CORNERS_SUCK_TIME_SCALE_FACTOR / (cornersSuckLevel * CORNERS_SUCK_LEVEL_SCALE_FACTOR);
                    const averageElapsedMs = Math.min(idleTimeMs, timeToMaxMs / 2);
                    const bonusRatio = Math.min(CORNERS_SUCK_MAX_MULTIPLIER - 1, (averageElapsedMs / CORNERS_SUCK_TIME_SCALE_FACTOR) * (cornersSuckLevel * CORNERS_SUCK_LEVEL_SCALE_FACTOR));
                    tvHitValue *= (1 + bonusRatio);
                }

                const hitsPerSecPerBox = IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR * tvSpeedFactor;
                const idleHitsPerTvPerSec = numBoxes * hitsPerSecPerBox * tvHitValue;
                totalIdleHitsPerSec += idleHitsPerTvPerSec;
            });
            // Apply global synergy bonus AFTER summing individual TV base HPS
            const totalEffectiveIdleHitsPerSec = totalIdleHitsPerSec * globalState.synergyBonus * devSpeedFactor;
            const totalGainedHits = totalEffectiveIdleHitsPerSec * (idleTimeMs / 1000);
            return Math.max(0, Math.floor(totalGainedHits));
        }


        // --- Handle Visibility Change ---
        function handleVisibilityChange() {
            const now = performance.now(); const dateNow = Date.now();
            if (document.hidden) {
                timeHidden = now; saveGame();
                if (gameLoopInterval) { clearInterval(gameLoopInterval); gameLoopInterval = null; }
            } else {
                if (timeHidden !== null) {
                    const idleTimeMs = now - timeHidden;
                    if (idleTimeMs >= MIN_OFFLINE_TIME_MS) {
                         // Ensure state is updated before calculating gains
                         updateAllTvsPostMeta();
                         recalculateGlobalSynergy();
                         hitsThresholdCache = {};
                        const gainedHits = calculateIdleGains(idleTimeMs);
                        if (gainedHits > 0) {
                            globalState.totalSessionHits += gainedHits; globalState.lifetimeSessionHits += gainedHits;
                            showNotification(`Gained ${formatScore(gainedHits)} Hits while tab was inactive.`);
                            updateTotalHitsDisplay(); updateAllTvGlows();
                             if (upgradeModal.classList.contains('show')) {
                                updateSelectedTvUpgradeButtons(); updateMetaUpgradeButtonsIfVisible(); updateRebootPreviewIfVisible();
                            }
                        }
                    }
                    timeHidden = null;
                }
                lastTimestamp = performance.now();
                 if (!gameLoopInterval) { gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS); }
                 requestAnimationFrame(handleGlobalResize);
                 globalState.tvStates.forEach((tv, index) => checkAndAdjustBoxPositions(index));
                 updateScreenBurnButtonState(dateNow);
                 updateCornerBetButtonState();
            }
        }

        // --- DEV Tools Functionality ---
        const devButton = document.getElementById('dev-button');
        const devPanel = document.getElementById('dev-panel');
        const devSimulateCornerButton = document.getElementById('dev-simulate-corner');
        const devHardResetButton = document.getElementById('dev-hard-reset');
        const devSpeedInput = document.getElementById('dev-speed-input');
        const devResetBurnCdButton = document.getElementById('dev-reset-burn-cd');

        if (devButton && devPanel) { devButton.addEventListener('click', () => { devPanel.classList.toggle('hidden'); }); }
        if (devSimulateCornerButton) {
            devSimulateCornerButton.addEventListener('click', () => {
                if (!globalState || !globalState.tvStates || globalState.tvStates.length === 0) { showNotification("DEV: No TVs available!"); return; }
                const tvIndex = Math.floor(Math.random() * globalState.tvStates.length); const tvState = globalState.tvStates[tvIndex];
                if (!tvState || !tvState.elements || !tvState.elements.screen || !tvState.screenWidth || tvState.screenWidth <= 0) { showNotification("DEV: TV not ready!"); return; }
                console.log(`DEV: Simulating corner hit on TV #${tvState.id + 1}`);

                tvState.lastCornerHitTimestamp = Date.now();
                const betWasActive = globalState.isCornerBetActive;
                if (betWasActive) {
                    resolveCornerBet(true);
                     showNotification(`DEV: Simulated Corner Hit (Resolved Bet WIN!)`);
                } else {
                    recalculateDerivedTvState(tvState); // Ensure derived values are current
                    const finalCornerBonus = Math.ceil(tvState.cornerHitBaseBonus * tvState.cornerHitMultiplier * globalState.synergyBonus * devSpeedFactor);
                    addTvHitScore(finalCornerBonus); updateTotalHitsDisplay();
                    const cornerX = 0; const cornerY = 0; createSparkParticles(tvState, cornerX, cornerY);
                    showFloatText(tvState, `CORNER HIT!\n+${formatScore(finalCornerBonus)}`, tvState.screenWidth / 2, tvState.screenHeight / 2, 'corner');
                    showNotification(`DEV: Simulated Corner Hit on TV ${tvState.id + 1} (+${formatScore(finalCornerBonus)} Hits)`);
                    updateTvGlow(tvIndex); updateAllTvGlows();
                    if (upgradeModal.classList.contains('show')) {
                         hitsThresholdCache = {}; updateSelectedTvUpgradeButtons(); updateMetaUpgradeButtonsIfVisible(); updateRebootPreviewIfVisible();
                     }
                }
            });
        }
        if (devResetBurnCdButton) {
            devResetBurnCdButton.addEventListener('click', () => {
                if (globalState) {
                    globalState.screenBurnCooldownEndTimestamp = 0; updateScreenBurnButtonState(Date.now());
                    showNotification("DEV: Screen Burn cooldown reset."); console.log("DEV: Screen Burn cooldown reset."); saveGame();
                }
            });
        }
        if (devSpeedInput) {
            devSpeedInput.value = devSpeedFactor;
            devSpeedInput.addEventListener('input', () => {
                let newSpeed = parseFloat(devSpeedInput.value); if (isNaN(newSpeed) || newSpeed <= 0) { newSpeed = 0.1; devSpeedInput.value = newSpeed; }
                if (devSpeedFactor !== newSpeed) {
                    devSpeedFactor = newSpeed; console.log(`DEV: Score Factor set to ${devSpeedFactor}`);
                    if (upgradeModal.classList.contains('show')) { hitsThresholdCache = {}; updateMetaUpgradeButtonsIfVisible(); updateRebootPreviewIfVisible(); }
                }
            });
        }
        if (devHardResetButton) {
            devHardResetButton.addEventListener('click', () => {
                if (confirm('HARD RESET GAME?\n\nThis will erase ALL saved progress and reload the page.')) {
                    console.warn("DEV: Performing hard reset."); localStorage.removeItem(SAVE_KEY);
                    showNotification("DEV: Hard Resetting..."); if(devPanel) devPanel.classList.add('hidden');
                    if(gameLoopInterval) clearInterval(gameLoopInterval); location.reload(true);
                }
            });
        }
        // --- End DEV Tools Functionality ---


        // --- Initialization ---
        async function init() {
             const startTime = performance.now();
             try {
                 console.log("Preloading images..."); await preloadImages([DVD_LOGO_URL, TV_BACKGROUND_URL]); console.log("Images preloaded.");
             } catch (error) { console.error("Image preloading issues:", error); }

             loadGame();

             // --- Event Listeners ---
             modalCloseButton.addEventListener('click', closeUpgradeModal);
             upgradeModal.addEventListener('click', (e) => { if (e.target === upgradeModal) closeUpgradeModal(); });
             metaMenuButton.addEventListener('click', () => openUpgradeModal(-1));
             screenBurnButton.addEventListener('click', activateScreenBurn);
             cornerBetButton.addEventListener('click', activateCornerBet);
             window.addEventListener('resize', handleGlobalResize);
             document.addEventListener('visibilitychange', handleVisibilityChange);

             // --- Start Game Loop ---
             lastTimestamp = performance.now(); lastSaveTime = Date.now();
             if (!document.hidden) { gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS); }
             console.log("Initialization complete.");

             // --- Loading screen minimum time ---
             const endTime = performance.now(); const elapsedTime = endTime - startTime;
             const delayTime = Math.max(0, MIN_LOADING_TIME_MS - elapsedTime);
             console.log(`Initialization took ${elapsedTime.toFixed(0)}ms. Delaying hide by ${delayTime.toFixed(0)}ms.`);
             setTimeout(() => {
                 if (loadingScreen) {
                     loadingScreen.classList.add('hidden');
                     setTimeout(() => { if (loadingScreen && loadingScreen.parentNode) { loadingScreen.parentNode.removeChild(loadingScreen); } }, 500);
                 }
             }, delayTime);
        }

        // --- Start ---
        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); }
        else { init(); }

    })();
</script>

</body>
</html>
